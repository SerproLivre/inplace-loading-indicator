// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../../@angular/common
//   ../../../../@angular/core
//   ../../../../rxjs/Observable

declare module '@angular/router' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Location } from '@angular/common';
    import { Compiler, Injector, NgModuleFactoryLoader, Type } from '@angular/core';
    import { Observable } from 'rxjs/Observable';
    import { QueryParamsHandling, Routes } from '@angular/router/config';
    import { Event } from '@angular/router/events';
    import { DetachedRouteHandle, RouteReuseStrategy } from '@angular/router/route_reuse_strategy';
    import { RouterOutletMap } from '@angular/router/router_outlet_map';
    import { ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot } from '@angular/router/router_state';
    import { Params } from '@angular/router/shared';
    import { UrlHandlingStrategy } from '@angular/router/url_handling_strategy';
    import { UrlSerializer, UrlTree } from '@angular/router/url_tree';
    /**
        * @whatItDoes Represents the extra options used during navigation.
        *
        * @stable
        */
    export interface NavigationExtras {
            /**
             * Enables relative navigation from the current ActivatedRoute.
             *
             * Configuration:
             *
             * ```
             * [{
             *   path: 'parent',
             *   component: ParentComponent,
             *   children: [{
             *     path: 'list',
             *     component: ListComponent
             *   },{
             *     path: 'child',
             *     component: ChildComponent
             *   }]
             * }]
             * ```
             *
             * Navigate to list route from child route:
             *
             * ```
             *  @Component({...})
             *  class ChildComponent {
             *    constructor(private router: Router, private route: ActivatedRoute) {}
             *
             *    go() {
             *      this.router.navigate(['../list'], { relativeTo: this.route });
             *    }
             *  }
             * ```
             */
            relativeTo?: ActivatedRoute | null;
            /**
             * Sets query parameters to the URL.
             *
             * ```
             * // Navigate to /results?page=1
             * this.router.navigate(['/results'], { queryParams: { page: 1 } });
             * ```
             */
            queryParams?: Params | null;
            /**
             * Sets the hash fragment for the URL.
             *
             * ```
             * // Navigate to /results#top
             * this.router.navigate(['/results'], { fragment: 'top' });
             * ```
             */
            fragment?: string;
            /**
             * Preserves the query parameters for the next navigation.
             *
             * deprecated, use `queryParamsHandling` instead
             *
             * ```
             * // Preserve query params from /results?page=1 to /view?page=1
             * this.router.navigate(['/view'], { preserveQueryParams: true });
             * ```
             *
             * @deprecated since v4
             */
            preserveQueryParams?: boolean;
            /**
             *  config strategy to handle the query parameters for the next navigation.
             *
             * ```
             * // from /results?page=1 to /view?page=1&page=2
             * this.router.navigate(['/view'], { queryParams: { page: 2 },  queryParamsHandling: "merge" });
             * ```
             */
            queryParamsHandling?: QueryParamsHandling | null;
            /**
             * Preserves the fragment for the next navigation
             *
             * ```
             * // Preserve fragment from /results#top to /view#top
             * this.router.navigate(['/view'], { preserveFragment: true });
             * ```
             */
            preserveFragment?: boolean;
            /**
             * Navigates without pushing a new state into history.
             *
             * ```
             * // Navigate silently to /view
             * this.router.navigate(['/view'], { skipLocationChange: true });
             * ```
             */
            skipLocationChange?: boolean;
            /**
             * Navigates while replacing the current state in history.
             *
             * ```
             * // Navigate to /view
             * this.router.navigate(['/view'], { replaceUrl: true });
             * ```
             */
            replaceUrl?: boolean;
    }
    /**
        * @whatItDoes Error handler that is invoked when a navigation errors.
        *
        * @description
        * If the handler returns a value, the navigation promise will be resolved with this value.
        * If the handler throws an exception, the navigation promise will be rejected with
        * the exception.
        *
        * @stable
        */
    export type ErrorHandler = (error: any) => any;
    /**
        * Does not detach any subtrees. Reuses routes as long as their route config is the same.
        */
    export class DefaultRouteReuseStrategy implements RouteReuseStrategy {
            shouldDetach(route: ActivatedRouteSnapshot): boolean;
            store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void;
            shouldAttach(route: ActivatedRouteSnapshot): boolean;
            retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;
            shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;
    }
    /**
        * @whatItDoes Provides the navigation and url manipulation capabilities.
        *
        * See {@link Routes} for more details and examples.
        *
        * @ngModule RouterModule
        *
        * @stable
        */
    export class Router {
            config: Routes;
            /**
                * Error handler that is invoked when a navigation errors.
                *
                * See {@link ErrorHandler} for more information.
                */
            errorHandler: ErrorHandler;
            /**
                * Indicates if at least one navigation happened.
                */
            navigated: boolean;
            /**
                * Extracts and merges URLs. Used for AngularJS to Angular migrations.
                */
            urlHandlingStrategy: UrlHandlingStrategy;
            routeReuseStrategy: RouteReuseStrategy;
            /**
                * Creates the router service.
                */
            constructor(rootComponentType: Type<any> | null, urlSerializer: UrlSerializer, outletMap: RouterOutletMap, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes);
            /**
                * Sets up the location change listener and performs the initial navigation.
                */
            initialNavigation(): void;
            /**
                * Sets up the location change listener.
                */
            setUpLocationChangeListener(): void;
            /** The current route state */
            readonly routerState: RouterState;
            /** The current url */
            readonly url: string;
            /** An observable of router events */
            readonly events: Observable<Event>;
            /**
                * Resets the configuration used for navigation and generating links.
                *
                * ### Usage
                *
                * ```
                * router.resetConfig([
                *  { path: 'team/:id', component: TeamCmp, children: [
                *    { path: 'simple', component: SimpleCmp },
                *    { path: 'user/:name', component: UserCmp }
                *  ]}
                * ]);
                * ```
                */
            resetConfig(config: Routes): void;
            /** @docsNotRequired */
            ngOnDestroy(): void;
            /** Disposes of the router */
            dispose(): void;
            /**
                * Applies an array of commands to the current url tree and creates a new url tree.
                *
                * When given an activate route, applies the given commands starting from the route.
                * When not given a route, applies the given command starting from the root.
                *
                * ### Usage
                *
                * ```
                * // create /team/33/user/11
                * router.createUrlTree(['/team', 33, 'user', 11]);
                *
                * // create /team/33;expand=true/user/11
                * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
                *
                * // you can collapse static segments like this (this works only with the first passed-in value):
                * router.createUrlTree(['/team/33/user', userId]);
                *
                * // If the first segment can contain slashes, and you do not want the router to split it, you
                * // can do the following:
                *
                * router.createUrlTree([{segmentPath: '/one/two'}]);
                *
                * // create /team/33/(user/11//right:chat)
                * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
                *
                * // remove the right secondary node
                * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
                *
                * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
                *
                * // navigate to /team/33/user/11/details
                * router.createUrlTree(['details'], {relativeTo: route});
                *
                * // navigate to /team/33/user/22
                * router.createUrlTree(['../22'], {relativeTo: route});
                *
                * // navigate to /team/44/user/22
                * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
                * ```
                */
            createUrlTree(commands: any[], {relativeTo, queryParams, fragment, preserveQueryParams, queryParamsHandling, preserveFragment}?: NavigationExtras): UrlTree;
            /**
                * Navigate based on the provided url. This navigation is always absolute.
                *
                * Returns a promise that:
                * - resolves to 'true' when navigation succeeds,
                * - resolves to 'false' when navigation fails,
                * - is rejected when an error happens.
                *
                * ### Usage
                *
                * ```
                * router.navigateByUrl("/team/33/user/11");
                *
                * // Navigate without updating the URL
                * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
                * ```
                *
                * In opposite to `navigate`, `navigateByUrl` takes a whole URL
                * and does not apply any delta to the current one.
                */
            navigateByUrl(url: string | UrlTree, extras?: NavigationExtras): Promise<boolean>;
            /**
                * Navigate based on the provided array of commands and a starting point.
                * If no starting route is provided, the navigation is absolute.
                *
                * Returns a promise that:
                * - resolves to 'true' when navigation succeeds,
                * - resolves to 'false' when navigation fails,
                * - is rejected when an error happens.
                *
                * ### Usage
                *
                * ```
                * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
                *
                * // Navigate without updating the URL
                * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
                * ```
                *
                * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current
                * URL.
                */
            navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;
            /** Serializes a {@link UrlTree} into a string */
            serializeUrl(url: UrlTree): string;
            /** Parses a string into a {@link UrlTree} */
            parseUrl(url: string): UrlTree;
            /** Returns whether the url is activated */
            isActive(url: string | UrlTree, exact: boolean): boolean;
    }
    export class PreActivation {
            constructor(future: RouterStateSnapshot, curr: RouterStateSnapshot, moduleInjector: Injector);
            traverse(parentOutletMap: RouterOutletMap): void;
            checkGuards(): Observable<boolean>;
            resolveData(): Observable<any>;
    }
}

declare module '@angular/router/config' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { NgModuleFactory, NgModuleRef, Type } from '@angular/core';
    import { Observable } from 'rxjs/Observable';
    import { UrlSegment, UrlSegmentGroup } from '@angular/router/url_tree';
    /**
        * @whatItDoes Represents router configuration.
        *
        * @description
        * `Routes` is an array of route configurations. Each one has the following properties:
        *
        * - `path` is a string that uses the route matcher DSL.
        * - `pathMatch` is a string that specifies the matching strategy.
        * - `matcher` defines a custom strategy for path matching and supersedes `path` and `pathMatch`.
        *   See {@link UrlMatcher} for more info.
        * - `component` is a component type.
        * - `redirectTo` is the url fragment which will replace the current matched segment.
        * - `outlet` is the name of the outlet the component should be placed into.
        * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See
        *   {@link CanActivate} for more info.
        * - `canActivateChild` is an array of DI tokens used to look up CanActivateChild handlers. See
        *   {@link CanActivateChild} for more info.
        * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See
        *   {@link CanDeactivate} for more info.
        * - `canLoad` is an array of DI tokens used to look up CanDeactivate handlers. See
        *   {@link CanLoad} for more info.
        * - `data` is additional data provided to the component via `ActivatedRoute`.
        * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more
        *   info.
        * - `runGuardsAndResolvers` defines when guards and resovlers will be run. By default they run only
        *    when the matrix parameters of the route change. When set to `paramsOrQueryParamsChange` they
        *    will also run when query params change. And when set to `always`, they will run every time.
        * - `children` is an array of child route definitions.
        * - `loadChildren` is a reference to lazy loaded child routes. See {@link LoadChildren} for more
        *   info.
        *
        * ### Simple Configuration
        *
        * ```
        * [{
        *   path: 'team/:id',
         *  component: Team,
        *   children: [{
        *     path: 'user/:name',
        *     component: User
        *   }]
        * }]
        * ```
        *
        * When navigating to `/team/11/user/bob`, the router will create the team component with the user
        * component in it.
        *
        * ### Multiple Outlets
        *
        * ```
        * [{
        *   path: 'team/:id',
        *   component: Team
        * }, {
        *   path: 'chat/:user',
        *   component: Chat
        *   outlet: 'aux'
        * }]
        * ```
        *
        * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to
        * the chat component. The chat component will be placed into the aux outlet.
        *
        * ### Wild Cards
        *
        * ```
        * [{
        *   path: '**',
        *   component: Sink
        * }]
        * ```
        *
        * Regardless of where you navigate to, the router will instantiate the sink component.
        *
        * ### Redirects
        *
        * ```
        * [{
        *   path: 'team/:id',
        *   component: Team,
        *   children: [{
        *     path: 'legacy/user/:name',
        *     redirectTo: 'user/:name'
        *   }, {
        *     path: 'user/:name',
        *     component: User
        *   }]
        * }]
        * ```
        *
        * When navigating to '/team/11/legacy/user/jim', the router will change the url to
        * '/team/11/user/jim', and then will instantiate the team component with the user component
        * in it.
        *
        * If the `redirectTo` value starts with a '/', then it is an absolute redirect. E.g., if in the
        * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.
        *
        * ### Empty Path
        *
        * Empty-path route configurations can be used to instantiate components that do not 'consume'
        * any url segments. Let's look at the following configuration:
        *
        * ```
        * [{
        *   path: 'team/:id',
        *   component: Team,
        *   children: [{
        *     path: '',
        *     component: AllUsers
        *   }, {
        *     path: 'user/:name',
        *     component: User
        *   }]
        * }]
        * ```
        *
        * When navigating to `/team/11`, the router will instantiate the AllUsers component.
        *
        * Empty-path routes can have children.
        *
        * ```
        * [{
        *   path: 'team/:id',
        *   component: Team,
        *   children: [{
        *     path: '',
        *     component: WrapperCmp,
        *     children: [{
        *       path: 'user/:name',
        *       component: User
        *     }]
        *   }]
        * }]
        * ```
        *
        * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with
        * the user component in it.
        *
        * An empty path route inherits its parent's params and data. This is because it cannot have its
        * own params, and, as a result, it often uses its parent's params and data as its own.
        *
        * ### Matching Strategy
        *
        * By default the router will look at what is left in the url, and check if it starts with
        * the specified path (e.g., `/team/11/user` starts with `team/:id`).
        *
        * We can change the matching strategy to make sure that the path covers the whole unconsumed url,
        * which is akin to `unconsumedUrl === path` or `$` regular expressions.
        *
        * This is particularly important when redirecting empty-path routes.
        *
        * ```
        * [{
        *   path: '',
        *   pathMatch: 'prefix', //default
        *   redirectTo: 'main'
        * }, {
        *   path: 'main',
        *   component: Main
        * }]
        * ```
        *
        * Since an empty path is a prefix of any url, even when navigating to '/main', the router will
        * still apply the redirect.
        *
        * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to
        * '/'.
        *
        * ```
        * [{
        *   path: '',
        *   pathMatch: 'full',
        *   redirectTo: 'main'
        * }, {
        *   path: 'main',
        *   component: Main
        * }]
        * ```
        *
        * ### Componentless Routes
        *
        * It is useful at times to have the ability to share parameters between sibling components.
        *
        * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both
        * of them require some id parameter.
        *
        * One way to do that would be to have a bogus parent component, so both the siblings can get the id
        * parameter from it. This is not ideal. Instead, you can use a componentless route.
        *
        * ```
        * [{
        *    path: 'parent/:id',
        *    children: [
        *      { path: 'a', component: MainChild },
        *      { path: 'b', component: AuxChild, outlet: 'aux' }
        *    ]
        * }]
        * ```
        *
        * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux
        * child components next to each other. In this example, the application component
        * has to have the primary and aux outlets defined.
        *
        * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into
        * the `params`, `data`, and `resolve` of the children. This is done because there is no component
        * that can inject the activated route of the componentless parent.
        *
        * This is especially useful when child components are defined as follows:
        *
        * ```
        * [{
        *    path: 'parent/:id',
        *    children: [
        *      { path: '', component: MainChild },
        *      { path: '', component: AuxChild, outlet: 'aux' }
        *    ]
        * }]
        * ```
        *
        * With this configuration in place, navigating to '/parent/10' will create the main child and aux
        * components.
        *
        * ### Lazy Loading
        *
        * Lazy loading speeds up our application load time by splitting it into multiple bundles, and
        * loading them on demand. The router is designed to make lazy loading simple and easy. Instead of
        * providing the children property, you can provide the `loadChildren` property, as follows:
        *
        * ```
        * [{
        *   path: 'team/:id',
        *   component: Team,
        *   loadChildren: 'team'
        * }]
        * ```
        *
        * The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.
        * Then it will extract the set of routes defined in that NgModule, and will transparently add
        * those routes to the main configuration.
        *
        * @stable use Routes
        */
    export type Routes = Route[];
    /**
        * @whatItDoes Represents the results of the URL matching.
        *
        * * `consumed` is an array of the consumed URL segments.
        * * `posParams` is a map of positional parameters.
        *
        * @experimental
        */
    export type UrlMatchResult = {
            consumed: UrlSegment[];
            posParams?: {
                    [name: string]: UrlSegment;
            };
    };
    /**
        * @whatItDoes A function matching URLs
        *
        * @description
        *
        * A custom URL matcher can be provided when a combination of `path` and `pathMatch` isn't
        * expressive enough.
        *
        * For instance, the following matcher matches html files.
        *
        * ```
        * function htmlFiles(url: UrlSegment[]) {
        *  return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;
        * }
        *
        * const routes = [{ matcher: htmlFiles, component: HtmlCmp }];
        * ```
        *
        * @experimental
        */
    export type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult;
    /**
        * @whatItDoes Represents the static data associated with a particular route.
        * See {@link Routes} for more details.
        * @stable
        */
    export type Data = {
            [name: string]: any;
    };
    /**
        * @whatItDoes Represents the resolved data associated with a particular route.
        * See {@link Routes} for more details.
        * @stable
        */
    export type ResolveData = {
            [name: string]: any;
    };
    /**
        * @whatItDoes The type of `loadChildren`.
        * See {@link Routes} for more details.
        * @stable
        */
    export type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Promise<Type<any>> | Observable<Type<any>>;
    /**
        * @whatItDoes The type of `loadChildren`.
        * See {@link Routes} for more details.
        * @stable
        */
    export type LoadChildren = string | LoadChildrenCallback;
    /**
        * @whatItDoes The type of `queryParamsHandling`.
        * See {@link RouterLink} for more details.
        * @stable
        */
    export type QueryParamsHandling = 'merge' | 'preserve' | '';
    /**
        * @whatItDoes The type of `runGuardsAndResolvers`.
        * See {@link Routes} for more details.
        * @experimental
        */
    export type RunGuardsAndResolvers = 'paramsChange' | 'paramsOrQueryParamsChange' | 'always';
    /**
        * See {@link Routes} for more details.
        * @stable
        */
    export interface Route {
            path?: string;
            pathMatch?: string;
            matcher?: UrlMatcher;
            component?: Type<any>;
            redirectTo?: string;
            outlet?: string;
            canActivate?: any[];
            canActivateChild?: any[];
            canDeactivate?: any[];
            canLoad?: any[];
            data?: Data;
            resolve?: ResolveData;
            children?: Routes;
            loadChildren?: LoadChildren;
            runGuardsAndResolvers?: RunGuardsAndResolvers;
    }
    export class LoadedRouterConfig {
            routes: Route[];
            module: NgModuleRef<any>;
            constructor(routes: Route[], module: NgModuleRef<any>);
    }
    export function validateConfig(config: Routes, parentPath?: string): void;
}

declare module '@angular/router/events' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Route } from '@angular/router/config';
    import { RouterStateSnapshot } from '@angular/router/router_state';
    /**
        * @whatItDoes Represents an event triggered when a navigation starts.
        *
        * @stable
        */
    export class NavigationStart {
            /** @docsNotRequired */
            id: number;
            /** @docsNotRequired */
            url: string;
            constructor(
                    /** @docsNotRequired */
                    id: number, 
                    /** @docsNotRequired */
                    url: string);
            /** @docsNotRequired */
            toString(): string;
    }
    /**
        * @whatItDoes Represents an event triggered when a navigation ends successfully.
        *
        * @stable
        */
    export class NavigationEnd {
            /** @docsNotRequired */
            id: number;
            /** @docsNotRequired */
            url: string;
            /** @docsNotRequired */
            urlAfterRedirects: string;
            constructor(
                    /** @docsNotRequired */
                    id: number, 
                    /** @docsNotRequired */
                    url: string, 
                    /** @docsNotRequired */
                    urlAfterRedirects: string);
            /** @docsNotRequired */
            toString(): string;
    }
    /**
        * @whatItDoes Represents an event triggered when a navigation is canceled.
        *
        * @stable
        */
    export class NavigationCancel {
            /** @docsNotRequired */
            id: number;
            /** @docsNotRequired */
            url: string;
            /** @docsNotRequired */
            reason: string;
            constructor(
                    /** @docsNotRequired */
                    id: number, 
                    /** @docsNotRequired */
                    url: string, 
                    /** @docsNotRequired */
                    reason: string);
            /** @docsNotRequired */
            toString(): string;
    }
    /**
        * @whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.
        *
        * @stable
        */
    export class NavigationError {
            /** @docsNotRequired */
            id: number;
            /** @docsNotRequired */
            url: string;
            /** @docsNotRequired */
            error: any;
            constructor(
                    /** @docsNotRequired */
                    id: number, 
                    /** @docsNotRequired */
                    url: string, 
                    /** @docsNotRequired */
                    error: any);
            /** @docsNotRequired */
            toString(): string;
    }
    /**
        * @whatItDoes Represents an event triggered when routes are recognized.
        *
        * @stable
        */
    export class RoutesRecognized {
            /** @docsNotRequired */
            id: number;
            /** @docsNotRequired */
            url: string;
            /** @docsNotRequired */
            urlAfterRedirects: string;
            /** @docsNotRequired */
            state: RouterStateSnapshot;
            constructor(
                    /** @docsNotRequired */
                    id: number, 
                    /** @docsNotRequired */
                    url: string, 
                    /** @docsNotRequired */
                    urlAfterRedirects: string, 
                    /** @docsNotRequired */
                    state: RouterStateSnapshot);
            /** @docsNotRequired */
            toString(): string;
    }
    /**
        * @whatItDoes Represents an event triggered before lazy loading a route config.
        *
        * @experimental
        */
    export class RouteConfigLoadStart {
            route: Route;
            constructor(route: Route);
            toString(): string;
    }
    /**
        * @whatItDoes Represents an event triggered when a route has been lazy loaded.
        *
        * @experimental
        */
    export class RouteConfigLoadEnd {
            route: Route;
            constructor(route: Route);
            toString(): string;
    }
    /**
        * @whatItDoes Represents a router event.
        *
        * One of:
        * - {@link NavigationStart},
        * - {@link NavigationEnd},
        * - {@link NavigationCancel},
        * - {@link NavigationError},
        * - {@link RoutesRecognized},
        * - {@link RouteConfigLoadStart},
        * - {@link RouteConfigLoadEnd}
        *
        * @stable
        */
    export type Event = NavigationStart | NavigationEnd | NavigationCancel | NavigationError | RoutesRecognized | RouteConfigLoadStart | RouteConfigLoadEnd;
}

declare module '@angular/router/route_reuse_strategy' {
    import { ActivatedRouteSnapshot } from '@angular/router/router_state';
    /**
        * @whatItDoes Represents the detached route tree.
        *
        * This is an opaque value the router will give to a custom route reuse strategy
        * to store and retrieve later on.
        *
        * @experimental
        */
    export type DetachedRouteHandle = {};
    /**
        * @whatItDoes Provides a way to customize when activated routes get reused.
        *
        * @experimental
        */
    export abstract class RouteReuseStrategy {
            /** Determines if this route (and its subtree) should be detached to be reused later */
            abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;
            /** Stores the detached route */
            abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;
            /** Determines if this route (and its subtree) should be reattached */
            abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;
            /** Retrieves the previously stored route */
            abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;
            /** Determines if a route should be reused */
            abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;
    }
}

declare module '@angular/router/router_outlet_map' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { RouterOutlet } from '@angular/router/directives/router_outlet';
    /**
        * @whatItDoes Contains all the router outlets created in a component.
        *
        * @stable
        */
    export class RouterOutletMap {
            /**
                * Adds an outlet to this map.
                */
            registerOutlet(name: string, outlet: RouterOutlet): void;
            /**
                * Removes an outlet from this map.
                */
            removeOutlet(name: string): void;
    }
}

declare module '@angular/router/router_state' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Type } from '@angular/core';
    import { Observable } from 'rxjs/Observable';
    import { Data, Route } from '@angular/router/config';
    import { ParamMap, Params } from '@angular/router/shared';
    import { UrlSegment, UrlTree } from '@angular/router/url_tree';
    import { Tree } from '@angular/router/utils/tree';
    /**
        * @whatItDoes Represents the state of the router.
        *
        * @howToUse
        *
        * ```
        * @Component({templateUrl:'template.html'})
        * class MyComponent {
        *   constructor(router: Router) {
        *     const state: RouterState = router.routerState;
        *     const root: ActivatedRoute = state.root;
        *     const child = root.firstChild;
        *     const id: Observable<string> = child.params.map(p => p.id);
        *     //...
        *   }
        * }
        * ```
        *
        * @description
        * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
        * segments, the extracted parameters, and the resolved data.
        *
        * See {@link ActivatedRoute} for more information.
        *
        * @stable
        */
    export class RouterState extends Tree<ActivatedRoute> {
            /** The current snapshot of the router state */
            snapshot: RouterStateSnapshot;
            toString(): string;
    }
    export function createEmptyState(urlTree: UrlTree, rootComponent: Type<any> | null): RouterState;
    export function createEmptyStateSnapshot(urlTree: UrlTree, rootComponent: Type<any> | null): RouterStateSnapshot;
    /**
        * @whatItDoes Contains the information about a route associated with a component loaded in an
        * outlet.
        * An `ActivatedRoute` can also be used to traverse the router state tree.
        *
        * @howToUse
        *
        * ```
        * @Component({...})
        * class MyComponent {
        *   constructor(route: ActivatedRoute) {
        *     const id: Observable<string> = route.params.map(p => p.id);
        *     const url: Observable<string> = route.url.map(segments => segments.join(''));
        *     // route.data includes both `data` and `resolve`
        *     const user = route.data.map(d => d.user);
        *   }
        * }
        * ```
        *
        * @stable
        */
    export class ActivatedRoute {
            /** An observable of the URL segments matched by this route */
            url: Observable<UrlSegment[]>;
            /** An observable of the matrix parameters scoped to this route */
            params: Observable<Params>;
            /** An observable of the query parameters shared by all the routes */
            queryParams: Observable<Params>;
            /** An observable of the URL fragment shared by all the routes */
            fragment: Observable<string>;
            /** An observable of the static and resolved data of this route. */
            data: Observable<Data>;
            /** The outlet name of the route. It's a constant */
            outlet: string;
            /** The component of the route. It's a constant */
            component: Type<any> | string | null;
            /** The current snapshot of this route */
            snapshot: ActivatedRouteSnapshot;
            /** The configuration used to match this route */
            readonly routeConfig: Route | null;
            /** The root of the router state */
            readonly root: ActivatedRoute;
            /** The parent of this route in the router state tree */
            readonly parent: ActivatedRoute | null;
            /** The first child of this route in the router state tree */
            readonly firstChild: ActivatedRoute | null;
            /** The children of this route in the router state tree */
            readonly children: ActivatedRoute[];
            /** The path from the root of the router state tree to this route */
            readonly pathFromRoot: ActivatedRoute[];
            readonly paramMap: Observable<ParamMap>;
            readonly queryParamMap: Observable<ParamMap>;
            toString(): string;
    }
    /**
        * @whatItDoes Contains the information about a route associated with a component loaded in an
        * outlet
        * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router
        * state tree.
        *
        * @howToUse
        *
        * ```
        * @Component({templateUrl:'./my-component.html'})
        * class MyComponent {
        *   constructor(route: ActivatedRoute) {
        *     const id: string = route.snapshot.params.id;
        *     const url: string = route.snapshot.url.join('');
        *     const user = route.snapshot.data.user;
        *   }
        * }
        * ```
        *
        * @stable
        */
    export class ActivatedRouteSnapshot {
            /** The URL segments matched by this route */
            url: UrlSegment[];
            /** The matrix parameters scoped to this route */
            params: Params;
            /** The query parameters shared by all the routes */
            queryParams: Params;
            /** The URL fragment shared by all the routes */
            fragment: string;
            /** The static and resolved data of this route */
            data: Data;
            /** The outlet name of the route */
            outlet: string;
            /** The component of the route */
            component: Type<any> | string | null;
            /** The configuration used to match this route */
            readonly routeConfig: Route | null;
            /** The root of the router state */
            readonly root: ActivatedRouteSnapshot;
            /** The parent of this route in the router state tree */
            readonly parent: ActivatedRouteSnapshot | null;
            /** The first child of this route in the router state tree */
            readonly firstChild: ActivatedRouteSnapshot | null;
            /** The children of this route in the router state tree */
            readonly children: ActivatedRouteSnapshot[];
            /** The path from the root of the router state tree to this route */
            readonly pathFromRoot: ActivatedRouteSnapshot[];
            readonly paramMap: ParamMap;
            readonly queryParamMap: ParamMap;
            toString(): string;
    }
    /**
        * @whatItDoes Represents the state of the router at a moment in time.
        *
        * @howToUse
        *
        * ```
        * @Component({templateUrl:'template.html'})
        * class MyComponent {
        *   constructor(router: Router) {
        *     const state: RouterState = router.routerState;
        *     const snapshot: RouterStateSnapshot = state.snapshot;
        *     const root: ActivatedRouteSnapshot = snapshot.root;
        *     const child = root.firstChild;
        *     const id: Observable<string> = child.params.map(p => p.id);
        *     //...
        *   }
        * }
        * ```
        *
        * @description
        * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about
        * the "consumed" URL segments, the extracted parameters, and the resolved data.
        *
        * @stable
        */
    export class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {
            /** The url from which this snapshot was created */
            url: string;
            toString(): string;
    }
    /**
        * The expectation is that the activate route is created with the right set of parameters.
        * So we push new values into the observables only when they are not the initial values.
        * And we detect that by checking if the snapshot field is set.
        */
    export function advanceActivatedRoute(route: ActivatedRoute): void;
    export function equalParamsAndUrlSegments(a: ActivatedRouteSnapshot, b: ActivatedRouteSnapshot): boolean;
}

declare module '@angular/router/shared' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Route, UrlMatchResult } from '@angular/router/config';
    import { UrlSegment, UrlSegmentGroup } from '@angular/router/url_tree';
    /**
        * @whatItDoes Name of the primary outlet.
        *
        * @stable
        */
    export const PRIMARY_OUTLET = "primary";
    /**
        * A collection of parameters.
        *
        * @stable
        */
    export type Params = {
            [key: string]: any;
    };
    /**
        * Matrix and Query parameters.
        *
        * `ParamMap` makes it easier to work with parameters as they could have either a single value or
        * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the
        * correct type (either `string` or `string[]`).
        *
        * The API is inspired by the URLSearchParams interface.
        * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
        *
        * @stable
        */
    export interface ParamMap {
            has(name: string): boolean;
            /**
                * Return a single value for the given parameter name:
                * - the value when the parameter has a single value,
                * - the first value if the parameter has multiple values,
                * - `null` when there is no such parameter.
                */
            get(name: string): string | null;
            /**
                * Return an array of values for the given parameter name.
                *
                * If there is no such parameter, an empty array is returned.
                */
            getAll(name: string): string[];
            /** Name of the parameters */
            readonly keys: string[];
    }
    /**
        * Convert a {@link Params} instance to a {@link ParamMap}.
        *
        * @stable
        */
    export function convertToParamMap(params: Params): ParamMap;
    export function navigationCancelingError(message: string): Error;
    export function isNavigationCancelingError(error: Error): any;
    export function defaultUrlMatcher(segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult | null;
}

declare module '@angular/router/url_handling_strategy' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { UrlTree } from '@angular/router/url_tree';
    /**
        * @whatItDoes Provides a way to migrate AngularJS applications to Angular.
        *
        * @experimental
        */
    export abstract class UrlHandlingStrategy {
            /**
                * Tells the router if this URL should be processed.
                *
                * When it returns true, the router will execute the regular navigation.
                * When it returns false, the router will set the router state to an empty state.
                * As a result, all the active components will be destroyed.
                *
                */
            abstract shouldProcessUrl(url: UrlTree): boolean;
            /**
                * Extracts the part of the URL that should be handled by the router.
                * The rest of the URL will remain untouched.
                */
            abstract extract(url: UrlTree): UrlTree;
            /**
                * Merges the URL fragment with the rest of the URL.
                */
            abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;
    }
    /**
        * @experimental
        */
    export class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {
            shouldProcessUrl(url: UrlTree): boolean;
            extract(url: UrlTree): UrlTree;
            merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree;
    }
}

declare module '@angular/router/url_tree' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { ParamMap } from '@angular/router/shared';
    export function createEmptyUrlTree(): UrlTree;
    export function containsTree(container: UrlTree, containee: UrlTree, exact: boolean): boolean;
    /**
        * @whatItDoes Represents the parsed URL.
        *
        * @howToUse
        *
        * ```
        * @Component({templateUrl:'template.html'})
        * class MyComponent {
        *   constructor(router: Router) {
        *     const tree: UrlTree =
        *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
        *     const f = tree.fragment; // return 'fragment'
        *     const q = tree.queryParams; // returns {debug: 'true'}
        *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
        *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
        *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
        *     g.children['support'].segments; // return 1 segment 'help'
        *   }
        * }
        * ```
        *
        * @description
        *
        * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
        * serialized tree.
        * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
        *
        * @stable
        */
    export class UrlTree {
            /** The root segment group of the URL tree */
            root: UrlSegmentGroup;
            /** The query params of the URL */
            queryParams: {
                    [key: string]: string;
            };
            /** The fragment of the URL */
            fragment: string | null;
            readonly queryParamMap: ParamMap;
            /** @docsNotRequired */
            toString(): string;
    }
    /**
        * @whatItDoes Represents the parsed URL segment group.
        *
        * See {@link UrlTree} for more information.
        *
        * @stable
        */
    export class UrlSegmentGroup {
            /** The URL segments of this group. See {@link UrlSegment} for more information */
            segments: UrlSegment[];
            /** The list of children of this group */
            children: {
                    [key: string]: UrlSegmentGroup;
            };
            /** The parent node in the url tree */
            parent: UrlSegmentGroup | null;
            constructor(
                    /** The URL segments of this group. See {@link UrlSegment} for more information */
                    segments: UrlSegment[], 
                    /** The list of children of this group */
                    children: {
                    [key: string]: UrlSegmentGroup;
            });
            /** Wether the segment has child segments */
            hasChildren(): boolean;
            /** Number of child segments */
            readonly numberOfChildren: number;
            /** @docsNotRequired */
            toString(): string;
    }
    /**
        * @whatItDoes Represents a single URL segment.
        *
        * @howToUse
        *
        * ```
        * @Component({templateUrl:'template.html'})
        * class MyComponent {
        *   constructor(router: Router) {
        *     const tree: UrlTree = router.parseUrl('/team;id=33');
        *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
        *     const s: UrlSegment[] = g.segments;
        *     s[0].path; // returns 'team'
        *     s[0].parameters; // returns {id: 33}
        *   }
        * }
        * ```
        *
        * @description
        *
        * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
        * parameters associated with the segment.
        *
        * @stable
        */
    export class UrlSegment {
            /** The path part of a URL segment */
            path: string;
            /** The matrix parameters associated with a segment */
            parameters: {
                    [name: string]: string;
            };
            constructor(
                    /** The path part of a URL segment */
                    path: string, 
                    /** The matrix parameters associated with a segment */
                    parameters: {
                    [name: string]: string;
            });
            readonly parameterMap: ParamMap;
            /** @docsNotRequired */
            toString(): string;
    }
    export function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean;
    export function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean;
    export function mapChildrenIntoArray<T>(segment: UrlSegmentGroup, fn: (v: UrlSegmentGroup, k: string) => T[]): T[];
    /**
        * @whatItDoes Serializes and deserializes a URL string into a URL tree.
        *
        * @description The url serialization strategy is customizable. You can
        * make all URLs case insensitive by providing a custom UrlSerializer.
        *
        * See {@link DefaultUrlSerializer} for an example of a URL serializer.
        *
        * @stable
        */
    export abstract class UrlSerializer {
            /** Parse a url into a {@link UrlTree} */
            abstract parse(url: string): UrlTree;
            /** Converts a {@link UrlTree} into a url */
            abstract serialize(tree: UrlTree): string;
    }
    /**
        * @whatItDoes A default implementation of the {@link UrlSerializer}.
        *
        * @description
        *
        * Example URLs:
        *
        * ```
        * /inbox/33(popup:compose)
        * /inbox/33;open=true/messages/44
        * ```
        *
        * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
        * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
        * specify route specific parameters.
        *
        * @stable
        */
    export class DefaultUrlSerializer implements UrlSerializer {
            /** Parses a url into a {@link UrlTree} */
            parse(url: string): UrlTree;
            /** Converts a {@link UrlTree} into a url */
            serialize(tree: UrlTree): string;
    }
    export function serializePaths(segment: UrlSegmentGroup): string;
    export function encode(s: string): string;
    export function decode(s: string): string;
    export function serializePath(path: UrlSegment): string;
}

declare module '@angular/router/directives/router_outlet' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { ComponentFactoryResolver, ComponentRef, EventEmitter, Injector, OnDestroy, ResolvedReflectiveProvider, ViewContainerRef } from '@angular/core';
    import { RouterOutletMap } from '@angular/router/router_outlet_map';
    import { ActivatedRoute } from '@angular/router/router_state';
    /**
        * @whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router
        * state.
        *
        * @howToUse
        *
        * ```
        * <router-outlet></router-outlet>
        * <router-outlet name='left'></router-outlet>
        * <router-outlet name='right'></router-outlet>
        * ```
        *
        * A router outlet will emit an activate event any time a new component is being instantiated,
        * and a deactivate event when it is being destroyed.
        *
        * ```
        * <router-outlet
        *   (activate)='onActivate($event)'
        *   (deactivate)='onDeactivate($event)'></router-outlet>
        * ```
        * @ngModule RouterModule
        *
        * @stable
        */
    export class RouterOutlet implements OnDestroy {
            outletMap: RouterOutletMap;
            activateEvents: EventEmitter<any>;
            deactivateEvents: EventEmitter<any>;
            constructor(parentOutletMap: RouterOutletMap, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string);
            ngOnDestroy(): void;
            /** @deprecated since v4 **/
            readonly locationInjector: Injector;
            /** @deprecated since v4 **/
            readonly locationFactoryResolver: ComponentFactoryResolver;
            readonly isActivated: boolean;
            readonly component: Object;
            readonly activatedRoute: ActivatedRoute;
            detach(): ComponentRef<any>;
            attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void;
            deactivate(): void;
            /** @deprecated since v4, use {@link activateWith} */
            activate(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver, injector: Injector, providers: ResolvedReflectiveProvider[], outletMap: RouterOutletMap): void;
            activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null, outletMap: RouterOutletMap): void;
    }
}

declare module '@angular/router/utils/tree' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export class Tree<T> {
        constructor(root: TreeNode<T>);
        readonly root: T;
    }
    export class TreeNode<T> {
        value: T;
        children: TreeNode<T>[];
        constructor(value: T, children: TreeNode<T>[]);
        toString(): string;
    }
}

