// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../../@angular/common
//   ../../../../@angular/core
//   ../../../../rxjs/Observable

declare module '@angular/router' {

  export * from '@angular/router/config';
  export * from '@angular/router/events';
  export * from '@angular/router/route_reuse_strategy';
  export * from '@angular/router/router_outlet_map';
  export * from '@angular/router/router_state';
  export * from '@angular/router/shared';
  export * from '@angular/router/url_handling_strategy';
  export * from '@angular/router/url_tree';
  export * from '@angular/router/directives/router_outlet';
  export * from '@angular/router/utils/tree';
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { Location } from '@angular/common';
  import { Compiler, Injector, NgModuleFactoryLoader, Type } from '@angular/core';
  import { Observable } from 'rxjs/Observable';
  import { QueryParamsHandling, Routes } from '@angular/router/config';
  import { Event } from '@angular/router/events';
  import { DetachedRouteHandle, RouteReuseStrategy } from '@angular/router/route_reuse_strategy';
  import { RouterOutletMap } from '@angular/router/router_outlet_map';
  import { ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot } from '@angular/router/router_state';
  import { Params } from '@angular/router/shared';
  import { UrlHandlingStrategy } from '@angular/router/url_handling_strategy';
  import { UrlSerializer, UrlTree } from '@angular/router/url_tree';
  /**
      * @whatItDoes Represents the extra options used during navigation.
      *
      * @stable
      */
  export interface NavigationExtras {
    /**
     * Enables relative navigation from the current ActivatedRoute.
     *
     * Configuration:
     *
     * ```
     * [{
     *   path: 'parent',
     *   component: ParentComponent,
     *   children: [{
     *     path: 'list',
     *     component: ListComponent
     *   },{
     *     path: 'child',
     *     component: ChildComponent
     *   }]
     * }]
     * ```
     *
     * Navigate to list route from child route:
     *
     * ```
     *  @Component({...})
     *  class ChildComponent {
     *    constructor(private router: Router, private route: ActivatedRoute) {}
     *
     *    go() {
     *      this.router.navigate(['../list'], { relativeTo: this.route });
     *    }
     *  }
     * ```
     */
    relativeTo?: ActivatedRoute | null;
    /**
     * Sets query parameters to the URL.
     *
     * ```
     * // Navigate to /results?page=1
     * this.router.navigate(['/results'], { queryParams: { page: 1 } });
     * ```
     */
    queryParams?: Params | null;
    /**
     * Sets the hash fragment for the URL.
     *
     * ```
     * // Navigate to /results#top
     * this.router.navigate(['/results'], { fragment: 'top' });
     * ```
     */
    fragment?: string;
    /**
     * Preserves the query parameters for the next navigation.
     *
     * deprecated, use `queryParamsHandling` instead
     *
     * ```
     * // Preserve query params from /results?page=1 to /view?page=1
     * this.router.navigate(['/view'], { preserveQueryParams: true });
     * ```
     *
     * @deprecated since v4
     */
    preserveQueryParams?: boolean;
    /**
     *  config strategy to handle the query parameters for the next navigation.
     *
     * ```
     * // from /results?page=1 to /view?page=1&page=2
     * this.router.navigate(['/view'], { queryParams: { page: 2 },  queryParamsHandling: "merge" });
     * ```
     */
    queryParamsHandling?: QueryParamsHandling | null;
    /**
     * Preserves the fragment for the next navigation
     *
     * ```
     * // Preserve fragment from /results#top to /view#top
     * this.router.navigate(['/view'], { preserveFragment: true });
     * ```
     */
    preserveFragment?: boolean;
    /**
     * Navigates without pushing a new state into history.
     *
     * ```
     * // Navigate silently to /view
     * this.router.navigate(['/view'], { skipLocationChange: true });
     * ```
     */
    skipLocationChange?: boolean;
    /**
     * Navigates while replacing the current state in history.
     *
     * ```
     * // Navigate to /view
     * this.router.navigate(['/view'], { replaceUrl: true });
     * ```
     */
    replaceUrl?: boolean;
  }
  /**
      * @whatItDoes Error handler that is invoked when a navigation errors.
      *
      * @description
      * If the handler returns a value, the navigation promise will be resolved with this value.
      * If the handler throws an exception, the navigation promise will be rejected with
      * the exception.
      *
      * @stable
      */
  export type ErrorHandler = (error: any) => any;
  /**
      * Does not detach any subtrees. Reuses routes as long as their route config is the same.
      */
  export class DefaultRouteReuseStrategy implements RouteReuseStrategy {
    shouldDetach(route: ActivatedRouteSnapshot): boolean;
    store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void;
    shouldAttach(route: ActivatedRouteSnapshot): boolean;
    retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;
    shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;
  }
  /**
      * @whatItDoes Provides the navigation and url manipulation capabilities.
      *
      * See {@link Routes} for more details and examples.
      *
      * @ngModule RouterModule
      *
      * @stable
      */
  export class Router {
    config: Routes;
    /**
        * Error handler that is invoked when a navigation errors.
        *
        * See {@link ErrorHandler} for more information.
        */
    errorHandler: ErrorHandler;
    /**
        * Indicates if at least one navigation happened.
        */
    navigated: boolean;
    /**
        * Extracts and merges URLs. Used for AngularJS to Angular migrations.
        */
    urlHandlingStrategy: UrlHandlingStrategy;
    routeReuseStrategy: RouteReuseStrategy;
    /**
        * Creates the router service.
        */
    constructor(rootComponentType: Type<any> | null, urlSerializer: UrlSerializer, outletMap: RouterOutletMap, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes);
    /**
        * Sets up the location change listener and performs the initial navigation.
        */
    initialNavigation(): void;
    /**
        * Sets up the location change listener.
        */
    setUpLocationChangeListener(): void;
    /** The current route state */
    readonly routerState: RouterState;
    /** The current url */
    readonly url: string;
    /** An observable of router events */
    readonly events: Observable<Event>;
    /**
        * Resets the configuration used for navigation and generating links.
        *
        * ### Usage
        *
        * ```
        * router.resetConfig([
        *  { path: 'team/:id', component: TeamCmp, children: [
        *    { path: 'simple', component: SimpleCmp },
        *    { path: 'user/:name', component: UserCmp }
        *  ]}
        * ]);
        * ```
        */
    resetConfig(config: Routes): void;
    /** @docsNotRequired */
    ngOnDestroy(): void;
    /** Disposes of the router */
    dispose(): void;
    /**
        * Applies an array of commands to the current url tree and creates a new url tree.
        *
        * When given an activate route, applies the given commands starting from the route.
        * When not given a route, applies the given command starting from the root.
        *
        * ### Usage
        *
        * ```
        * // create /team/33/user/11
        * router.createUrlTree(['/team', 33, 'user', 11]);
        *
        * // create /team/33;expand=true/user/11
        * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
        *
        * // you can collapse static segments like this (this works only with the first passed-in value):
        * router.createUrlTree(['/team/33/user', userId]);
        *
        * // If the first segment can contain slashes, and you do not want the router to split it, you
        * // can do the following:
        *
        * router.createUrlTree([{segmentPath: '/one/two'}]);
        *
        * // create /team/33/(user/11//right:chat)
        * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
        *
        * // remove the right secondary node
        * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
        *
        * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
        *
        * // navigate to /team/33/user/11/details
        * router.createUrlTree(['details'], {relativeTo: route});
        *
        * // navigate to /team/33/user/22
        * router.createUrlTree(['../22'], {relativeTo: route});
        *
        * // navigate to /team/44/user/22
        * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
        * ```
        */
    createUrlTree(commands: any[], { relativeTo, queryParams, fragment, preserveQueryParams, queryParamsHandling, preserveFragment }?: NavigationExtras): UrlTree;
    /**
        * Navigate based on the provided url. This navigation is always absolute.
        *
        * Returns a promise that:
        * - resolves to 'true' when navigation succeeds,
        * - resolves to 'false' when navigation fails,
        * - is rejected when an error happens.
        *
        * ### Usage
        *
        * ```
        * router.navigateByUrl("/team/33/user/11");
        *
        * // Navigate without updating the URL
        * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
        * ```
        *
        * In opposite to `navigate`, `navigateByUrl` takes a whole URL
        * and does not apply any delta to the current one.
        */
    navigateByUrl(url: string | UrlTree, extras?: NavigationExtras): Promise<boolean>;
    /**
        * Navigate based on the provided array of commands and a starting point.
        * If no starting route is provided, the navigation is absolute.
        *
        * Returns a promise that:
        * - resolves to 'true' when navigation succeeds,
        * - resolves to 'false' when navigation fails,
        * - is rejected when an error happens.
        *
        * ### Usage
        *
        * ```
        * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
        *
        * // Navigate without updating the URL
        * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
        * ```
        *
        * In opposite to `navigateByUrl`, `navigate` always takes a delta that is applied to the current
        * URL.
        */
    navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;
    /** Serializes a {@link UrlTree} into a string */
    serializeUrl(url: UrlTree): string;
    /** Parses a string into a {@link UrlTree} */
    parseUrl(url: string): UrlTree;
    /** Returns whether the url is activated */
    isActive(url: string | UrlTree, exact: boolean): boolean;
  }
  export class PreActivation {
    constructor(future: RouterStateSnapshot, curr: RouterStateSnapshot, moduleInjector: Injector);
    traverse(parentOutletMap: RouterOutletMap): void;
    checkGuards(): Observable<boolean>;
    resolveData(): Observable<any>;
  }
}

declare module '@angular/router/config' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { NgModuleFactory, NgModuleRef, Type } from '@angular/core';
  import { Observable } from 'rxjs/Observable';
  import { UrlSegment, UrlSegmentGroup } from '@angular/router/url_tree';
  /**
      * @whatItDoes Represents router configuration.
      *
      * @description
      * `Routes` is an array of route configurations. Each one has the following properties:
      *
      * - `path` is a string that uses the route matcher DSL.
      * - `pathMatch` is a string that specifies the matching strategy.
      * - `matcher` defines a custom strategy for path matching and supersedes `path` and `pathMatch`.
      *   See {@link UrlMatcher} for more info.
      * - `component` is a component type.
      * - `redirectTo` is the url fragment which will replace the current matched segment.
      * - `outlet` is the name of the outlet the component should be placed into.
      * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See
      *   {@link CanActivate} for more info.
      * - `canActivateChild` is an array of DI tokens used to look up CanActivateChild handlers. See
      *   {@link CanActivateChild} for more info.
      * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See
      *   {@link CanDeactivate} for more info.
      * - `canLoad` is an array of DI tokens used to look up CanDeactivate handlers. See
      *   {@link CanLoad} for more info.
      * - `data` is additional data provided to the component via `ActivatedRoute`.
      * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more
      *   info.
      * - `runGuardsAndResolvers` defines when guards and resovlers will be run. By default they run only
      *    when the matrix parameters of the route change. When set to `paramsOrQueryParamsChange` they
      *    will also run when query params change. And when set to `always`, they will run every time.
      * - `children` is an array of child route definitions.
      * - `loadChildren` is a reference to lazy loaded child routes. See {@link LoadChildren} for more
      *   info.
      *
      * ### Simple Configuration
      *
      * ```
      * [{
      *   path: 'team/:id',
       *  component: Team,
      *   children: [{
      *     path: 'user/:name',
      *     component: User
      *   }]
      * }]
      * ```
      *
      * When navigating to `/team/11/user/bob`, the router will create the team component with the user
      * component in it.
      *
      * ### Multiple Outlets
      *
      * ```
      * [{
      *   path: 'team/:id',
      *   component: Team
      * }, {
      *   path: 'chat/:user',
      *   component: Chat
      *   outlet: 'aux'
      * }]
      * ```
      *
      * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to
      * the chat component. The chat component will be placed into the aux outlet.
      *
      * ### Wild Cards
      *
      * ```
      * [{
      *   path: '**',
      *   component: Sink
      * }]
      * ```
      *
      * Regardless of where you navigate to, the router will instantiate the sink component.
      *
      * ### Redirects
      *
      * ```
      * [{
      *   path: 'team/:id',
      *   component: Team,
      *   children: [{
      *     path: 'legacy/user/:name',
      *     redirectTo: 'user/:name'
      *   }, {
      *     path: 'user/:name',
      *     component: User
      *   }]
      * }]
      * ```
      *
      * When navigating to '/team/11/legacy/user/jim', the router will change the url to
      * '/team/11/user/jim', and then will instantiate the team component with the user component
      * in it.
      *
      * If the `redirectTo` value starts with a '/', then it is an absolute redirect. E.g., if in the
      * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.
      *
      * ### Empty Path
      *
      * Empty-path route configurations can be used to instantiate components that do not 'consume'
      * any url segments. Let's look at the following configuration:
      *
      * ```
      * [{
      *   path: 'team/:id',
      *   component: Team,
      *   children: [{
      *     path: '',
      *     component: AllUsers
      *   }, {
      *     path: 'user/:name',
      *     component: User
      *   }]
      * }]
      * ```
      *
      * When navigating to `/team/11`, the router will instantiate the AllUsers component.
      *
      * Empty-path routes can have children.
      *
      * ```
      * [{
      *   path: 'team/:id',
      *   component: Team,
      *   children: [{
      *     path: '',
      *     component: WrapperCmp,
      *     children: [{
      *       path: 'user/:name',
      *       component: User
      *     }]
      *   }]
      * }]
      * ```
      *
      * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with
      * the user component in it.
      *
      * An empty path route inherits its parent's params and data. This is because it cannot have its
      * own params, and, as a result, it often uses its parent's params and data as its own.
      *
      * ### Matching Strategy
      *
      * By default the router will look at what is left in the url, and check if it starts with
      * the specified path (e.g., `/team/11/user` starts with `team/:id`).
      *
      * We can change the matching strategy to make sure that the path covers the whole unconsumed url,
      * which is akin to `unconsumedUrl === path` or `$` regular expressions.
      *
      * This is particularly important when redirecting empty-path routes.
      *
      * ```
      * [{
      *   path: '',
      *   pathMatch: 'prefix', //default
      *   redirectTo: 'main'
      * }, {
      *   path: 'main',
      *   component: Main
      * }]
      * ```
      *
      * Since an empty path is a prefix of any url, even when navigating to '/main', the router will
      * still apply the redirect.
      *
      * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to
      * '/'.
      *
      * ```
      * [{
      *   path: '',
      *   pathMatch: 'full',
      *   redirectTo: 'main'
      * }, {
      *   path: 'main',
      *   component: Main
      * }]
      * ```
      *
      * ### Componentless Routes
      *
      * It is useful at times to have the ability to share parameters between sibling components.
      *
      * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both
      * of them require some id parameter.
      *
      * One way to do that would be to have a bogus parent component, so both the siblings can get the id
      * parameter from it. This is not ideal. Instead, you can use a componentless route.
      *
      * ```
      * [{
      *    path: 'parent/:id',
      *    children: [
      *      { path: 'a', component: MainChild },
      *      { path: 'b', component: AuxChild, outlet: 'aux' }
      *    ]
      * }]
      * ```
      *
      * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux
      * child components next to each other. In this example, the application component
      * has to have the primary and aux outlets defined.
      *
      * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into
      * the `params`, `data`, and `resolve` of the children. This is done because there is no component
      * that can inject the activated route of the componentless parent.
      *
      * This is especially useful when child components are defined as follows:
      *
      * ```
      * [{
      *    path: 'parent/:id',
      *    children: [
      *      { path: '', component: MainChild },
      *      { path: '', component: AuxChild, outlet: 'aux' }
      *    ]
      * }]
      * ```
      *
      * With this configuration in place, navigating to '/parent/10' will create the main child and aux
      * components.
      *
      * ### Lazy Loading
      *
      * Lazy loading speeds up our application load time by splitting it into multiple bundles, and
      * loading them on demand. The router is designed to make lazy loading simple and easy. Instead of
      * providing the children property, you can provide the `loadChildren` property, as follows:
      *
      * ```
      * [{
      *   path: 'team/:id',
      *   component: Team,
      *   loadChildren: 'team'
      * }]
      * ```
      *
      * The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.
      * Then it will extract the set of routes defined in that NgModule, and will transparently add
      * those routes to the main configuration.
      *
      * @stable use Routes
      */
  export type Routes = Route[];
  /**
      * @whatItDoes Represents the results of the URL matching.
      *
      * * `consumed` is an array of the consumed URL segments.
      * * `posParams` is a map of positional parameters.
      *
      * @experimental
      */
  export type UrlMatchResult = {
    consumed: UrlSegment[];
    posParams?: {
      [name: string]: UrlSegment;
    };
  };
  /**
      * @whatItDoes A function matching URLs
      *
      * @description
      *
      * A custom URL matcher can be provided when a combination of `path` and `pathMatch` isn't
      * expressive enough.
      *
      * For instance, the following matcher matches html files.
      *
      * ```
      * function htmlFiles(url: UrlSegment[]) {
      *  return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;
      * }
      *
      * const routes = [{ matcher: htmlFiles, component: HtmlCmp }];
      * ```
      *
      * @experimental
      */
  export type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult;
  /**
      * @whatItDoes Represents the static data associated with a particular route.
      * See {@link Routes} for more details.
      * @stable
      */
  export type Data = {
    [name: string]: any;
  };
  /**
      * @whatItDoes Represents the resolved data associated with a particular route.
      * See {@link Routes} for more details.
      * @stable
      */
  export type ResolveData = {
    [name: string]: any;
  };
  /**
      * @whatItDoes The type of `loadChildren`.
      * See {@link Routes} for more details.
      * @stable
      */
  export type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Promise<Type<any>> | Observable<Type<any>>;
  /**
      * @whatItDoes The type of `loadChildren`.
      * See {@link Routes} for more details.
      * @stable
      */
  export type LoadChildren = string | LoadChildrenCallback;
  /**
      * @whatItDoes The type of `queryParamsHandling`.
      * See {@link RouterLink} for more details.
      * @stable
      */
  export type QueryParamsHandling = 'merge' | 'preserve' | '';
  /**
      * @whatItDoes The type of `runGuardsAndResolvers`.
      * See {@link Routes} for more details.
      * @experimental
      */
  export type RunGuardsAndResolvers = 'paramsChange' | 'paramsOrQueryParamsChange' | 'always';
  /**
      * See {@link Routes} for more details.
      * @stable
      */
  export interface Route {
    path?: string;
    pathMatch?: string;
    matcher?: UrlMatcher;
    component?: Type<any>;
    redirectTo?: string;
    outlet?: string;
    canActivate?: any[];
    canActivateChild?: any[];
    canDeactivate?: any[];
    canLoad?: any[];
    data?: Data;
    resolve?: ResolveData;
    children?: Routes;
    loadChildren?: LoadChildren;
    runGuardsAndResolvers?: RunGuardsAndResolvers;
  }
  export class LoadedRouterConfig {
    routes: Route[];
    module: NgModuleRef<any>;
    constructor(routes: Route[], module: NgModuleRef<any>);
  }
  export function validateConfig(config: Routes, parentPath?: string): void;
}

declare module '@angular/router/events' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { Route } from '@angular/router/config';
  import { RouterStateSnapshot } from '@angular/router/router_state';
  /**
      * @whatItDoes Represents an event triggered when a navigation starts.
      *
      * @stable
      */
  export class NavigationStart {
    /** @docsNotRequired */
    id: number;
    /** @docsNotRequired */
    url: string;
    constructor(
      /** @docsNotRequired */
      id: number,
      /** @docsNotRequired */
      url: string);
    /** @docsNotRequired */
    toString(): string;
  }
  /**
      * @whatItDoes Represents an event triggered when a navigation ends successfully.
      *
      * @stable
      */
  export class NavigationEnd {
    /** @docsNotRequired */
    id: number;
    /** @docsNotRequired */
    url: string;
    /** @docsNotRequired */
    urlAfterRedirects: string;
    constructor(
      /** @docsNotRequired */
      id: number,
      /** @docsNotRequired */
      url: string,
      /** @docsNotRequired */
      urlAfterRedirects: string);
    /** @docsNotRequired */
    toString(): string;
  }
  /**
      * @whatItDoes Represents an event triggered when a navigation is canceled.
      *
      * @stable
      */
  export class NavigationCancel {
    /** @docsNotRequired */
    id: number;
    /** @docsNotRequired */
    url: string;
    /** @docsNotRequired */
    reason: string;
    constructor(
      /** @docsNotRequired */
      id: number,
      /** @docsNotRequired */
      url: string,
      /** @docsNotRequired */
      reason: string);
    /** @docsNotRequired */
    toString(): string;
  }
  /**
      * @whatItDoes Represents an event triggered when a navigation fails due to an unexpected error.
      *
      * @stable
      */
  export class NavigationError {
    /** @docsNotRequired */
    id: number;
    /** @docsNotRequired */
    url: string;
    /** @docsNotRequired */
    error: any;
    constructor(
      /** @docsNotRequired */
      id: number,
      /** @docsNotRequired */
      url: string,
      /** @docsNotRequired */
      error: any);
    /** @docsNotRequired */
    toString(): string;
  }
  /**
      * @whatItDoes Represents an event triggered when routes are recognized.
      *
      * @stable
      */
  export class RoutesRecognized {
    /** @docsNotRequired */
    id: number;
    /** @docsNotRequired */
    url: string;
    /** @docsNotRequired */
    urlAfterRedirects: string;
    /** @docsNotRequired */
    state: RouterStateSnapshot;
    constructor(
      /** @docsNotRequired */
      id: number,
      /** @docsNotRequired */
      url: string,
      /** @docsNotRequired */
      urlAfterRedirects: string,
      /** @docsNotRequired */
      state: RouterStateSnapshot);
    /** @docsNotRequired */
    toString(): string;
  }
  /**
      * @whatItDoes Represents an event triggered before lazy loading a route config.
      *
      * @experimental
      */
  export class RouteConfigLoadStart {
    route: Route;
    constructor(route: Route);
    toString(): string;
  }
  /**
      * @whatItDoes Represents an event triggered when a route has been lazy loaded.
      *
      * @experimental
      */
  export class RouteConfigLoadEnd {
    route: Route;
    constructor(route: Route);
    toString(): string;
  }
  /**
      * @whatItDoes Represents a router event.
      *
      * One of:
      * - {@link NavigationStart},
      * - {@link NavigationEnd},
      * - {@link NavigationCancel},
      * - {@link NavigationError},
      * - {@link RoutesRecognized},
      * - {@link RouteConfigLoadStart},
      * - {@link RouteConfigLoadEnd}
      *
      * @stable
      */
  export type Event = NavigationStart | NavigationEnd | NavigationCancel | NavigationError | RoutesRecognized | RouteConfigLoadStart | RouteConfigLoadEnd;
}

declare module '@angular/router/route_reuse_strategy' {
  import { ActivatedRouteSnapshot } from '@angular/router/router_state';
  /**
      * @whatItDoes Represents the detached route tree.
      *
      * This is an opaque value the router will give to a custom route reuse strategy
      * to store and retrieve later on.
      *
      * @experimental
      */
  export type DetachedRouteHandle = {};
  /**
      * @whatItDoes Provides a way to customize when activated routes get reused.
      *
      * @experimental
      */
  export abstract class RouteReuseStrategy {
    /** Determines if this route (and its subtree) should be detached to be reused later */
    abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;
    /** Stores the detached route */
    abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;
    /** Determines if this route (and its subtree) should be reattached */
    abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;
    /** Retrieves the previously stored route */
    abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;
    /** Determines if a route should be reused */
    abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;
  }
}

declare module '@angular/router/router_outlet_map' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { RouterOutlet } from '@angular/router/directives/router_outlet';
  /**
      * @whatItDoes Contains all the router outlets created in a component.
      *
      * @stable
      */
  export class RouterOutletMap {
    /**
        * Adds an outlet to this map.
        */
    registerOutlet(name: string, outlet: RouterOutlet): void;
    /**
        * Removes an outlet from this map.
        */
    removeOutlet(name: string): void;
  }
}

declare module '@angular/router/router_state' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { Type } from '@angular/core';
  import { Observable } from 'rxjs/Observable';
  import { Data, Route } from '@angular/router/config';
  import { ParamMap, Params } from '@angular/router/shared';
  import { UrlSegment, UrlTree } from '@angular/router/url_tree';
  import { Tree } from '@angular/router/utils/tree';
  /**
      * @whatItDoes Represents the state of the router.
      *
      * @howToUse
      *
      * ```
      * @Component({templateUrl:'template.html'})
      * class MyComponent {
      *   constructor(router: Router) {
      *     const state: RouterState = router.routerState;
      *     const root: ActivatedRoute = state.root;
      *     const child = root.firstChild;
      *     const id: Observable<string> = child.params.map(p => p.id);
      *     //...
      *   }
      * }
      * ```
      *
      * @description
      * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
      * segments, the extracted parameters, and the resolved data.
      *
      * See {@link ActivatedRoute} for more information.
      *
      * @stable
      */
  export class RouterState extends Tree<ActivatedRoute> {
    /** The current snapshot of the router state */
    snapshot: RouterStateSnapshot;
    toString(): string;
  }
  export function createEmptyState(urlTree: UrlTree, rootComponent: Type<any> | null): RouterState;
  export function createEmptyStateSnapshot(urlTree: UrlTree, rootComponent: Type<any> | null): RouterStateSnapshot;
  /**
      * @whatItDoes Contains the information about a route associated with a component loaded in an
      * outlet.
      * An `ActivatedRoute` can also be used to traverse the router state tree.
      *
      * @howToUse
      *
      * ```
      * @Component({...})
      * class MyComponent {
      *   constructor(route: ActivatedRoute) {
      *     const id: Observable<string> = route.params.map(p => p.id);
      *     const url: Observable<string> = route.url.map(segments => segments.join(''));
      *     // route.data includes both `data` and `resolve`
      *     const user = route.data.map(d => d.user);
      *   }
      * }
      * ```
      *
      * @stable
      */
  export class ActivatedRoute {
    /** An observable of the URL segments matched by this route */
    url: Observable<UrlSegment[]>;
    /** An observable of the matrix parameters scoped to this route */
    params: Observable<Params>;
    /** An observable of the query parameters shared by all the routes */
    queryParams: Observable<Params>;
    /** An observable of the URL fragment shared by all the routes */
    fragment: Observable<string>;
    /** An observable of the static and resolved data of this route. */
    data: Observable<Data>;
    /** The outlet name of the route. It's a constant */
    outlet: string;
    /** The component of the route. It's a constant */
    component: Type<any> | string | null;
    /** The current snapshot of this route */
    snapshot: ActivatedRouteSnapshot;
    /** The configuration used to match this route */
    readonly routeConfig: Route | null;
    /** The root of the router state */
    readonly root: ActivatedRoute;
    /** The parent of this route in the router state tree */
    readonly parent: ActivatedRoute | null;
    /** The first child of this route in the router state tree */
    readonly firstChild: ActivatedRoute | null;
    /** The children of this route in the router state tree */
    readonly children: ActivatedRoute[];
    /** The path from the root of the router state tree to this route */
    readonly pathFromRoot: ActivatedRoute[];
    readonly paramMap: Observable<ParamMap>;
    readonly queryParamMap: Observable<ParamMap>;
    toString(): string;
  }
  /**
      * @whatItDoes Contains the information about a route associated with a component loaded in an
      * outlet
      * at a particular moment in time. ActivatedRouteSnapshot can also be used to traverse the router
      * state tree.
      *
      * @howToUse
      *
      * ```
      * @Component({templateUrl:'./my-component.html'})
      * class MyComponent {
      *   constructor(route: ActivatedRoute) {
      *     const id: string = route.snapshot.params.id;
      *     const url: string = route.snapshot.url.join('');
      *     const user = route.snapshot.data.user;
      *   }
      * }
      * ```
      *
      * @stable
      */
  export class ActivatedRouteSnapshot {
    /** The URL segments matched by this route */
    url: UrlSegment[];
    /** The matrix parameters scoped to this route */
    params: Params;
    /** The query parameters shared by all the routes */
    queryParams: Params;
    /** The URL fragment shared by all the routes */
    fragment: string;
    /** The static and resolved data of this route */
    data: Data;
    /** The outlet name of the route */
    outlet: string;
    /** The component of the route */
    component: Type<any> | string | null;
    /** The configuration used to match this route */
    readonly routeConfig: Route | null;
    /** The root of the router state */
    readonly root: ActivatedRouteSnapshot;
    /** The parent of this route in the router state tree */
    readonly parent: ActivatedRouteSnapshot | null;
    /** The first child of this route in the router state tree */
    readonly firstChild: ActivatedRouteSnapshot | null;
    /** The children of this route in the router state tree */
    readonly children: ActivatedRouteSnapshot[];
    /** The path from the root of the router state tree to this route */
    readonly pathFromRoot: ActivatedRouteSnapshot[];
    readonly paramMap: ParamMap;
    readonly queryParamMap: ParamMap;
    toString(): string;
  }
  /**
      * @whatItDoes Represents the state of the router at a moment in time.
      *
      * @howToUse
      *
      * ```
      * @Component({templateUrl:'template.html'})
      * class MyComponent {
      *   constructor(router: Router) {
      *     const state: RouterState = router.routerState;
      *     const snapshot: RouterStateSnapshot = state.snapshot;
      *     const root: ActivatedRouteSnapshot = snapshot.root;
      *     const child = root.firstChild;
      *     const id: Observable<string> = child.params.map(p => p.id);
      *     //...
      *   }
      * }
      * ```
      *
      * @description
      * RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about
      * the "consumed" URL segments, the extracted parameters, and the resolved data.
      *
      * @stable
      */
  export class RouterStateSnapshot extends Tree<ActivatedRouteSnapshot> {
    /** The url from which this snapshot was created */
    url: string;
    toString(): string;
  }
  /**
      * The expectation is that the activate route is created with the right set of parameters.
      * So we push new values into the observables only when they are not the initial values.
      * And we detect that by checking if the snapshot field is set.
      */
  export function advanceActivatedRoute(route: ActivatedRoute): void;
  export function equalParamsAndUrlSegments(a: ActivatedRouteSnapshot, b: ActivatedRouteSnapshot): boolean;
}

declare module '@angular/router/shared' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { Route, UrlMatchResult } from '@angular/router/config';
  import { UrlSegment, UrlSegmentGroup } from '@angular/router/url_tree';
  /**
      * @whatItDoes Name of the primary outlet.
      *
      * @stable
      */
  export const PRIMARY_OUTLET = "primary";
  /**
      * A collection of parameters.
      *
      * @stable
      */
  export type Params = {
    [key: string]: any;
  };
  /**
      * Matrix and Query parameters.
      *
      * `ParamMap` makes it easier to work with parameters as they could have either a single value or
      * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the
      * correct type (either `string` or `string[]`).
      *
      * The API is inspired by the URLSearchParams interface.
      * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
      *
      * @stable
      */
  export interface ParamMap {
    has(name: string): boolean;
    /**
        * Return a single value for the given parameter name:
        * - the value when the parameter has a single value,
        * - the first value if the parameter has multiple values,
        * - `null` when there is no such parameter.
        */
    get(name: string): string | null;
    /**
        * Return an array of values for the given parameter name.
        *
        * If there is no such parameter, an empty array is returned.
        */
    getAll(name: string): string[];
    /** Name of the parameters */
    readonly keys: string[];
  }
  /**
      * Convert a {@link Params} instance to a {@link ParamMap}.
      *
      * @stable
      */
  export function convertToParamMap(params: Params): ParamMap;
  export function navigationCancelingError(message: string): Error;
  export function isNavigationCancelingError(error: Error): any;
  export function defaultUrlMatcher(segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult | null;
}

declare module '@angular/router/url_handling_strategy' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { UrlTree } from '@angular/router/url_tree';
  /**
      * @whatItDoes Provides a way to migrate AngularJS applications to Angular.
      *
      * @experimental
      */
  export abstract class UrlHandlingStrategy {
    /**
        * Tells the router if this URL should be processed.
        *
        * When it returns true, the router will execute the regular navigation.
        * When it returns false, the router will set the router state to an empty state.
        * As a result, all the active components will be destroyed.
        *
        */
    abstract shouldProcessUrl(url: UrlTree): boolean;
    /**
        * Extracts the part of the URL that should be handled by the router.
        * The rest of the URL will remain untouched.
        */
    abstract extract(url: UrlTree): UrlTree;
    /**
        * Merges the URL fragment with the rest of the URL.
        */
    abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;
  }
  /**
      * @experimental
      */
  export class DefaultUrlHandlingStrategy implements UrlHandlingStrategy {
    shouldProcessUrl(url: UrlTree): boolean;
    extract(url: UrlTree): UrlTree;
    merge(newUrlPart: UrlTree, wholeUrl: UrlTree): UrlTree;
  }
}

declare module '@angular/router/url_tree' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { ParamMap } from '@angular/router/shared';
  export function createEmptyUrlTree(): UrlTree;
  export function containsTree(container: UrlTree, containee: UrlTree, exact: boolean): boolean;
  /**
      * @whatItDoes Represents the parsed URL.
      *
      * @howToUse
      *
      * ```
      * @Component({templateUrl:'template.html'})
      * class MyComponent {
      *   constructor(router: Router) {
      *     const tree: UrlTree =
      *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
      *     const f = tree.fragment; // return 'fragment'
      *     const q = tree.queryParams; // returns {debug: 'true'}
      *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
      *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
      *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
      *     g.children['support'].segments; // return 1 segment 'help'
      *   }
      * }
      * ```
      *
      * @description
      *
      * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
      * serialized tree.
      * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
      *
      * @stable
      */
  export class UrlTree {
    /** The root segment group of the URL tree */
    root: UrlSegmentGroup;
    /** The query params of the URL */
    queryParams: {
      [key: string]: string;
    };
    /** The fragment of the URL */
    fragment: string | null;
    readonly queryParamMap: ParamMap;
    /** @docsNotRequired */
    toString(): string;
  }
  /**
      * @whatItDoes Represents the parsed URL segment group.
      *
      * See {@link UrlTree} for more information.
      *
      * @stable
      */
  export class UrlSegmentGroup {
    /** The URL segments of this group. See {@link UrlSegment} for more information */
    segments: UrlSegment[];
    /** The list of children of this group */
    children: {
      [key: string]: UrlSegmentGroup;
    };
    /** The parent node in the url tree */
    parent: UrlSegmentGroup | null;
    constructor(
      /** The URL segments of this group. See {@link UrlSegment} for more information */
      segments: UrlSegment[],
      /** The list of children of this group */
      children: {
        [key: string]: UrlSegmentGroup;
      });
    /** Wether the segment has child segments */
    hasChildren(): boolean;
    /** Number of child segments */
    readonly numberOfChildren: number;
    /** @docsNotRequired */
    toString(): string;
  }
  /**
      * @whatItDoes Represents a single URL segment.
      *
      * @howToUse
      *
      * ```
      * @Component({templateUrl:'template.html'})
      * class MyComponent {
      *   constructor(router: Router) {
      *     const tree: UrlTree = router.parseUrl('/team;id=33');
      *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
      *     const s: UrlSegment[] = g.segments;
      *     s[0].path; // returns 'team'
      *     s[0].parameters; // returns {id: 33}
      *   }
      * }
      * ```
      *
      * @description
      *
      * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
      * parameters associated with the segment.
      *
      * @stable
      */
  export class UrlSegment {
    /** The path part of a URL segment */
    path: string;
    /** The matrix parameters associated with a segment */
    parameters: {
      [name: string]: string;
    };
    constructor(
      /** The path part of a URL segment */
      path: string,
      /** The matrix parameters associated with a segment */
      parameters: {
        [name: string]: string;
      });
    readonly parameterMap: ParamMap;
    /** @docsNotRequired */
    toString(): string;
  }
  export function equalSegments(as: UrlSegment[], bs: UrlSegment[]): boolean;
  export function equalPath(as: UrlSegment[], bs: UrlSegment[]): boolean;
  export function mapChildrenIntoArray<T>(segment: UrlSegmentGroup, fn: (v: UrlSegmentGroup, k: string) => T[]): T[];
  /**
      * @whatItDoes Serializes and deserializes a URL string into a URL tree.
      *
      * @description The url serialization strategy is customizable. You can
      * make all URLs case insensitive by providing a custom UrlSerializer.
      *
      * See {@link DefaultUrlSerializer} for an example of a URL serializer.
      *
      * @stable
      */
  export abstract class UrlSerializer {
    /** Parse a url into a {@link UrlTree} */
    abstract parse(url: string): UrlTree;
    /** Converts a {@link UrlTree} into a url */
    abstract serialize(tree: UrlTree): string;
  }
  /**
      * @whatItDoes A default implementation of the {@link UrlSerializer}.
      *
      * @description
      *
      * Example URLs:
      *
      * ```
      * /inbox/33(popup:compose)
      * /inbox/33;open=true/messages/44
      * ```
      *
      * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
      * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
      * specify route specific parameters.
      *
      * @stable
      */
  export class DefaultUrlSerializer implements UrlSerializer {
    /** Parses a url into a {@link UrlTree} */
    parse(url: string): UrlTree;
    /** Converts a {@link UrlTree} into a url */
    serialize(tree: UrlTree): string;
  }
  export function serializePaths(segment: UrlSegmentGroup): string;
  export function encode(s: string): string;
  export function decode(s: string): string;
  export function serializePath(path: UrlSegment): string;
}

declare module '@angular/router/directives/router_outlet' {
  /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
  import { ComponentFactoryResolver, ComponentRef, EventEmitter, Injector, OnDestroy, ResolvedReflectiveProvider, ViewContainerRef } from '@angular/core';
  import { RouterOutletMap } from '@angular/router/router_outlet_map';
  import { ActivatedRoute } from '@angular/router/router_state';
  /**
      * @whatItDoes Acts as a placeholder that Angular dynamically fills based on the current router
      * state.
      *
      * @howToUse
      *
      * ```
      * <router-outlet></router-outlet>
      * <router-outlet name='left'></router-outlet>
      * <router-outlet name='right'></router-outlet>
      * ```
      *
      * A router outlet will emit an activate event any time a new component is being instantiated,
      * and a deactivate event when it is being destroyed.
      *
      * ```
      * <router-outlet
      *   (activate)='onActivate($event)'
      *   (deactivate)='onDeactivate($event)'></router-outlet>
      * ```
      * @ngModule RouterModule
      *
      * @stable
      */
  export class RouterOutlet implements OnDestroy {
    outletMap: RouterOutletMap;
    activateEvents: EventEmitter<any>;
    deactivateEvents: EventEmitter<any>;
    constructor(parentOutletMap: RouterOutletMap, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string);
    ngOnDestroy(): void;
    /** @deprecated since v4 **/
    readonly locationInjector: Injector;
    /** @deprecated since v4 **/
    readonly locationFactoryResolver: ComponentFactoryResolver;
    readonly isActivated: boolean;
    readonly component: Object;
    readonly activatedRoute: ActivatedRoute;
    detach(): ComponentRef<any>;
    attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void;
    deactivate(): void;
    /** @deprecated since v4, use {@link activateWith} */
    activate(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver, injector: Injector, providers: ResolvedReflectiveProvider[], outletMap: RouterOutletMap): void;
    activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null, outletMap: RouterOutletMap): void;
  }
}

declare module '@angular/router/utils/tree' {
  /**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
  export class Tree<T> {
    constructor(root: TreeNode<T>);
    readonly root: T;
  }
  export class TreeNode<T> {
    value: T;
    children: TreeNode<T>[];
    constructor(value: T, children: TreeNode<T>[]);
    toString(): string;
  }
}

