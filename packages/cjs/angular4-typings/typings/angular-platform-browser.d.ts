// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../../@angular/core
//   ../../../../@angular/common

declare module '@angular/platform-browser' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export { BrowserModule, platformBrowser } from '@angular/platform-browser/browser';
    export { Meta, MetaDefinition } from '@angular/platform-browser/browser/meta';
    export { Title } from '@angular/platform-browser/browser/title';
    export { disableDebugTools, enableDebugTools } from '@angular/platform-browser/browser/tools/tools';
    export { By } from '@angular/platform-browser/dom/debug/by';
    export { NgProbeToken } from '@angular/platform-browser/dom/debug/ng_probe';
    export { DOCUMENT } from '@angular/platform-browser/dom/dom_tokens';
    export { EVENT_MANAGER_PLUGINS, EventManager } from '@angular/platform-browser/dom/events/event_manager';
    export { HAMMER_GESTURE_CONFIG, HammerGestureConfig } from '@angular/platform-browser/dom/events/hammer_gestures';
    export { DomSanitizer, SafeHtml, SafeResourceUrl, SafeScript, SafeStyle, SafeUrl, SafeValue } from '@angular/platform-browser/security/dom_sanitization_service';
    export * from '@angular/platform-browser/private_export';
    export { VERSION } from '@angular/platform-browser/version';
}

declare module '@angular/platform-browser/browser' {
    export * from '@angular/core/browser'
    export * from '@angular/core/browser'
    export * from '@angular/core/browser'
    export * from '@angular/core/browser'
    export * from '@angular/core/browser'
    export * from '@angular/core/browser'
}

declare module '@angular/platform-browser/browser/meta' {
    /**
        * Represents a meta element.
        *
        * @experimental
        */
    export type MetaDefinition = {
            charset?: string;
            content?: string;
            httpEquiv?: string;
            id?: string;
            itemprop?: string;
            name?: string;
            property?: string;
            scheme?: string;
            url?: string;
    } & {
            [prop: string]: string;
    };
    /**
        * A service that can be used to get and add meta tags.
        *
        * @experimental
        */
    export class Meta {
            constructor(_doc: any);
            addTag(tag: MetaDefinition, forceCreation?: boolean): HTMLMetaElement | null;
            addTags(tags: MetaDefinition[], forceCreation?: boolean): HTMLMetaElement[];
            getTag(attrSelector: string): HTMLMetaElement | null;
            getTags(attrSelector: string): HTMLMetaElement[];
            updateTag(tag: MetaDefinition, selector?: string): HTMLMetaElement | null;
            removeTag(attrSelector: string): void;
            removeTagElement(meta: HTMLMetaElement): void;
    }
}

declare module '@angular/platform-browser/browser/title' {
    /**
        * A service that can be used to get and set the title of a current HTML document.
        *
        * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)
        * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
        * (representing the `<title>` tag). Instead, this service can be used to set and get the current
        * title value.
        *
        * @experimental
        */
    export class Title {
            constructor(_doc: any);
            /**
                * Get the title of the current HTML document.
                * @returns {string}
                */
            getTitle(): string;
            /**
                * Set the title of the current HTML document.
                * @param newTitle
                */
            setTitle(newTitle: string): void;
    }
}

declare module '@angular/platform-browser/browser/tools/tools' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { ComponentRef } from '@angular/core';
    /**
        * Enabled Angular debug tools that are accessible via your browser's
        * developer console.
        *
        * Usage:
        *
        * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
        * 1. Type `ng.` (usually the console will show auto-complete suggestion)
        * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
        *    then hit Enter.
        *
        * @experimental All debugging apis are currently experimental.
        */
    export function enableDebugTools<T>(ref: ComponentRef<T>): ComponentRef<T>;
    /**
        * Disables Angular tools.
        *
        * @experimental All debugging apis are currently experimental.
        */
    export function disableDebugTools(): void;
}

declare module '@angular/platform-browser/dom/debug/by' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { DebugElement, Predicate, Type } from '@angular/core';
    /**
        * Predicates for use with {@link DebugElement}'s query functions.
        *
        * @experimental All debugging apis are currently experimental.
        */
    export class By {
            /**
                * Match all elements.
                *
                * ## Example
                *
                * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
                */
            static all(): Predicate<DebugElement>;
            /**
                * Match elements by the given CSS selector.
                *
                * ## Example
                *
                * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
                */
            static css(selector: string): Predicate<DebugElement>;
            /**
                * Match elements that have the given directive present.
                *
                * ## Example
                *
                * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
                */
            static directive(type: Type<any>): Predicate<DebugElement>;
    }
}

declare module '@angular/platform-browser/dom/debug/ng_probe' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import * as core from '@angular/core';
    /**
        * Returns a {@link DebugElement} for the given native DOM element, or
        * null if the given native element does not have an Angular view associated
        * with it.
        */
    export function inspectNativeElement(element: any): core.DebugNode | null;
    /**
        * Deprecated. Use the one from '@angular/core'.
        * @deprecated
        */
    export class NgProbeToken {
            name: string;
            token: any;
            constructor(name: string, token: any);
    }
    export function _createNgProbe(extraTokens: NgProbeToken[], coreTokens: core.NgProbeToken[]): any;
    /**
        * Providers which support debugging Angular applications (e.g. via `ng.probe`).
        */
    export const ELEMENT_PROBE_PROVIDERS: core.Provider[];
}

declare module '@angular/platform-browser/dom/dom_tokens' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken } from '@angular/core';
    /**
        * A DI Token representing the main rendering context. In a browser this is the DOM Document.
        *
        * Note: Document might not be available in the Application Context when Application and Rendering
        * Contexts are not the same (e.g. when running the application into a Web Worker).
        *
        * @stable
        */
    export const DOCUMENT: InjectionToken<Document>;
}

declare module '@angular/platform-browser/dom/events/event_manager' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken, NgZone } from '@angular/core';
    /**
        * @stable
        */
    export const EVENT_MANAGER_PLUGINS: InjectionToken<EventManagerPlugin[]>;
    /**
        * @stable
        */
    export class EventManager {
            constructor(plugins: EventManagerPlugin[], _zone: NgZone);
            addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
            addGlobalEventListener(target: string, eventName: string, handler: Function): Function;
            getZone(): NgZone;
    }
    export abstract class EventManagerPlugin {
            constructor(_doc: any);
            manager: EventManager;
            abstract supports(eventName: string): boolean;
            abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
            addGlobalEventListener(element: string, eventName: string, handler: Function): Function;
    }
}

declare module '@angular/platform-browser/dom/events/hammer_gestures' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken } from '@angular/core';
    import { EventManagerPlugin } from '@angular/platform-browser/dom/events/event_manager';
    /**
        * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
        * Hammer gestures.
        *
        * @experimental
        */
    export const HAMMER_GESTURE_CONFIG: InjectionToken<HammerGestureConfig>;
    export interface HammerInstance {
            on(eventName: string, callback?: Function): void;
            off(eventName: string, callback?: Function): void;
    }
    /**
        * @experimental
        */
    export class HammerGestureConfig {
            events: string[];
            overrides: {
                    [key: string]: Object;
            };
            buildHammer(element: HTMLElement): HammerInstance;
    }
    export class HammerGesturesPlugin extends EventManagerPlugin {
            constructor(doc: any, _config: HammerGestureConfig);
            supports(eventName: string): boolean;
            addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
            isCustomEvent(eventName: string): boolean;
    }
}

declare module '@angular/platform-browser/security/dom_sanitization_service' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Sanitizer, SecurityContext } from '@angular/core';
    export { SecurityContext };
    /**
        * Marker interface for a value that's safe to use in a particular context.
        *
        * @stable
        */
    export interface SafeValue {
    }
    /**
        * Marker interface for a value that's safe to use as HTML.
        *
        * @stable
        */
    export interface SafeHtml extends SafeValue {
    }
    /**
        * Marker interface for a value that's safe to use as style (CSS).
        *
        * @stable
        */
    export interface SafeStyle extends SafeValue {
    }
    /**
        * Marker interface for a value that's safe to use as JavaScript.
        *
        * @stable
        */
    export interface SafeScript extends SafeValue {
    }
    /**
        * Marker interface for a value that's safe to use as a URL linking to a document.
        *
        * @stable
        */
    export interface SafeUrl extends SafeValue {
    }
    /**
        * Marker interface for a value that's safe to use as a URL to load executable code from.
        *
        * @stable
        */
    export interface SafeResourceUrl extends SafeValue {
    }
    /**
        * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
        * values to be safe to use in the different DOM contexts.
        *
        * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
        * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
        * the website.
        *
        * In specific situations, it might be necessary to disable sanitization, for example if the
        * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
        * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
        * methods, and then binding to that value from the template.
        *
        * These situations should be very rare, and extraordinary care must be taken to avoid creating a
        * Cross Site Scripting (XSS) security bug!
        *
        * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
        * close as possible to the source of the value, to make it easy to verify no security bug is
        * created by its use.
        *
        * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
        * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
        * code. The sanitizer leaves safe values intact.
        *
        * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
        * sanitization for the value passed in. Carefully check and audit all values and code paths going
        * into this call. Make sure any user data is appropriately escaped for this security context.
        * For more detail, see the [Security Guide](http://g.co/ng/security).
        *
        * @stable
        */
    export abstract class DomSanitizer implements Sanitizer {
            /**
                * Sanitizes a value for use in the given SecurityContext.
                *
                * If value is trusted for the context, this method will unwrap the contained safe value and use
                * it directly. Otherwise, value will be sanitized to be safe in the given context, for example
                * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation
                * is responsible to make sure that the value can definitely be safely used in the given context.
                */
            abstract sanitize(context: SecurityContext, value: SafeValue | string | null): string | null;
            /**
                * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML
                * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will
                * leave safe HTML intact, so in most situations this method should not be used.
                *
                * **WARNING:** calling this method with untrusted user data exposes your application to XSS
                * security risks!
                */
            abstract bypassSecurityTrustHtml(value: string): SafeHtml;
            /**
                * Bypass security and trust the given value to be safe style value (CSS).
                *
                * **WARNING:** calling this method with untrusted user data exposes your application to XSS
                * security risks!
                */
            abstract bypassSecurityTrustStyle(value: string): SafeStyle;
            /**
                * Bypass security and trust the given value to be safe JavaScript.
                *
                * **WARNING:** calling this method with untrusted user data exposes your application to XSS
                * security risks!
                */
            abstract bypassSecurityTrustScript(value: string): SafeScript;
            /**
                * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used
                * in hyperlinks or `<img src>`.
                *
                * **WARNING:** calling this method with untrusted user data exposes your application to XSS
                * security risks!
                */
            abstract bypassSecurityTrustUrl(value: string): SafeUrl;
            /**
                * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may
                * be used to load executable code from, like `<script src>`, or `<iframe src>`.
                *
                * **WARNING:** calling this method with untrusted user data exposes your application to XSS
                * security risks!
                */
            abstract bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl;
    }
    export class DomSanitizerImpl extends DomSanitizer {
            constructor(_doc: any);
            sanitize(ctx: SecurityContext, value: SafeValue | string | null): string | null;
            bypassSecurityTrustHtml(value: string): SafeHtml;
            bypassSecurityTrustStyle(value: string): SafeStyle;
            bypassSecurityTrustScript(value: string): SafeScript;
            bypassSecurityTrustUrl(value: string): SafeUrl;
            bypassSecurityTrustResourceUrl(value: string): SafeResourceUrl;
    }
}

declare module '@angular/platform-browser/private_export' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export { BROWSER_SANITIZATION_PROVIDERS as ɵBROWSER_SANITIZATION_PROVIDERS, INTERNAL_BROWSER_PLATFORM_PROVIDERS as ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS, initDomAdapter as ɵinitDomAdapter } from '@angular/platform-browser/browser';
    export { BrowserDomAdapter as ɵBrowserDomAdapter } from '@angular/platform-browser/browser/browser_adapter';
    export { setValueOnPath as ɵsetValueOnPath } from '@angular/platform-browser/browser/browser_adapter';
    export { BrowserPlatformLocation as ɵBrowserPlatformLocation } from '@angular/platform-browser/browser/location/browser_platform_location';
    export { TRANSITION_ID as ɵTRANSITION_ID } from '@angular/platform-browser/browser/server-transition';
    export { BrowserGetTestability as ɵBrowserGetTestability } from '@angular/platform-browser/browser/testability';
    export { ELEMENT_PROBE_PROVIDERS as ɵELEMENT_PROBE_PROVIDERS } from '@angular/platform-browser/dom/debug/ng_probe';
    export { DomAdapter as ɵDomAdapter, getDOM as ɵgetDOM, setRootDomAdapter as ɵsetRootDomAdapter } from '@angular/platform-browser/dom/dom_adapter';
    export { DomRendererFactory2 as ɵDomRendererFactory2, NAMESPACE_URIS as ɵNAMESPACE_URIS, flattenStyles as ɵflattenStyles, shimContentAttribute as ɵshimContentAttribute, shimHostAttribute as ɵshimHostAttribute } from '@angular/platform-browser/dom/dom_renderer';
    export { DomEventsPlugin as ɵDomEventsPlugin } from '@angular/platform-browser/dom/events/dom_events';
    export { HammerGesturesPlugin as ɵHammerGesturesPlugin } from '@angular/platform-browser/dom/events/hammer_gestures';
    export { KeyEventsPlugin as ɵKeyEventsPlugin } from '@angular/platform-browser/dom/events/key_events';
    export { DomSharedStylesHost as ɵDomSharedStylesHost, SharedStylesHost as ɵSharedStylesHost } from '@angular/platform-browser/dom/shared_styles_host';
}

declare module '@angular/platform-browser/version' {
    /**
        * @module
        * @description
        * Entry point for all public APIs of the common package.
        */
    import { Version } from '@angular/core';
    /**
        * @stable
        */
    export const VERSION: Version;
}

declare module '@angular/platform-browser/browser/browser_adapter' {
    import { GenericBrowserDomAdapter } from '@angular/platform-browser/browser/generic_browser_adapter';
    /**
      * A `DomAdapter` powered by full browser DOM APIs.
      *
      * @security Tread carefully! Interacting with the DOM directly is dangerous and
      * can introduce XSS risks.
      */
    export class BrowserDomAdapter extends GenericBrowserDomAdapter {
        parse(templateHtml: string): void;
        static makeCurrent(): void;
        hasProperty(element: Node, name: string): boolean;
        setProperty(el: Node, name: string, value: any): void;
        getProperty(el: Node, name: string): any;
        invoke(el: Node, methodName: string, args: any[]): any;
        logError(error: string): void;
        log(error: string): void;
        logGroup(error: string): void;
        logGroupEnd(): void;
        readonly attrToPropMap: any;
        contains(nodeA: any, nodeB: any): boolean;
        querySelector(el: Element, selector: string): any;
        querySelectorAll(el: any, selector: string): any[];
        on(el: Node, evt: any, listener: any): void;
        onAndCancel(el: Node, evt: any, listener: any): Function;
        dispatchEvent(el: Node, evt: any): void;
        createMouseEvent(eventType: string): MouseEvent;
        createEvent(eventType: any): Event;
        preventDefault(evt: Event): void;
        isPrevented(evt: Event): boolean;
        getInnerHTML(el: HTMLElement): string;
        getTemplateContent(el: Node): Node | null;
        getOuterHTML(el: HTMLElement): string;
        nodeName(node: Node): string;
        nodeValue(node: Node): string | null;
        type(node: HTMLInputElement): string;
        content(node: Node): Node;
        firstChild(el: Node): Node | null;
        nextSibling(el: Node): Node | null;
        parentElement(el: Node): Node | null;
        childNodes(el: any): Node[];
        childNodesAsList(el: Node): any[];
        clearNodes(el: Node): void;
        appendChild(el: Node, node: Node): void;
        removeChild(el: Node, node: Node): void;
        replaceChild(el: Node, newChild: Node, oldChild: Node): void;
        remove(node: Node): Node;
        insertBefore(parent: Node, ref: Node, node: Node): void;
        insertAllBefore(parent: Node, ref: Node, nodes: Node[]): void;
        insertAfter(parent: Node, ref: Node, node: any): void;
        setInnerHTML(el: Element, value: string): void;
        getText(el: Node): string | null;
        setText(el: Node, value: string): void;
        getValue(el: any): string;
        setValue(el: any, value: string): void;
        getChecked(el: any): boolean;
        setChecked(el: any, value: boolean): void;
        createComment(text: string): Comment;
        createTemplate(html: any): HTMLElement;
        createElement(tagName: string, doc?: Document): HTMLElement;
        createElementNS(ns: string, tagName: string, doc?: Document): Element;
        createTextNode(text: string, doc?: Document): Text;
        createScriptTag(attrName: string, attrValue: string, doc?: Document): HTMLScriptElement;
        createStyleElement(css: string, doc?: Document): HTMLStyleElement;
        createShadowRoot(el: HTMLElement): DocumentFragment;
        getShadowRoot(el: HTMLElement): DocumentFragment;
        getHost(el: HTMLElement): HTMLElement;
        clone(node: Node): Node;
        getElementsByClassName(element: any, name: string): HTMLElement[];
        getElementsByTagName(element: any, name: string): HTMLElement[];
        classList(element: any): any[];
        addClass(element: any, className: string): void;
        removeClass(element: any, className: string): void;
        hasClass(element: any, className: string): boolean;
        setStyle(element: any, styleName: string, styleValue: string): void;
        removeStyle(element: any, stylename: string): void;
        getStyle(element: any, stylename: string): string;
        hasStyle(element: any, styleName: string, styleValue?: string | null): boolean;
        tagName(element: any): string;
        attributeMap(element: any): Map<string, string>;
        hasAttribute(element: Element, attribute: string): boolean;
        hasAttributeNS(element: Element, ns: string, attribute: string): boolean;
        getAttribute(element: Element, attribute: string): string | null;
        getAttributeNS(element: Element, ns: string, name: string): string;
        setAttribute(element: Element, name: string, value: string): void;
        setAttributeNS(element: Element, ns: string, name: string, value: string): void;
        removeAttribute(element: Element, attribute: string): void;
        removeAttributeNS(element: Element, ns: string, name: string): void;
        templateAwareRoot(el: Node): any;
        createHtmlDocument(): HTMLDocument;
        getBoundingClientRect(el: Element): any;
        getTitle(doc: Document): string;
        setTitle(doc: Document, newTitle: string): void;
        elementMatches(n: any, selector: string): boolean;
        isTemplateElement(el: Node): boolean;
        isTextNode(node: Node): boolean;
        isCommentNode(node: Node): boolean;
        isElementNode(node: Node): boolean;
        hasShadowRoot(node: any): boolean;
        isShadowRoot(node: any): boolean;
        importIntoDoc(node: Node): any;
        adoptNode(node: Node): any;
        getHref(el: Element): string;
        getEventKey(event: any): string;
        getGlobalEventTarget(doc: Document, target: string): EventTarget | null;
        getHistory(): History;
        getLocation(): Location;
        getBaseHref(doc: Document): string | null;
        resetBaseElement(): void;
        getUserAgent(): string;
        setData(element: Element, name: string, value: string): void;
        getData(element: Element, name: string): string | null;
        getComputedStyle(element: any): any;
        setGlobalVar(path: string, value: any): void;
        supportsWebAnimation(): boolean;
        performanceNow(): number;
        supportsCookies(): boolean;
        getCookie(name: string): string | null;
        setCookie(name: string, value: string): void;
    }
    export function parseCookieValue(cookieStr: string, name: string): string | null;
    export function setValueOnPath(global: any, path: string, value: any): void;
}

declare module '@angular/platform-browser/browser/location/browser_platform_location' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { LocationChangeListener, PlatformLocation } from '@angular/common';
    /**
        * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
        * This class should not be used directly by an application developer. Instead, use
        * {@link Location}.
        */
    export class BrowserPlatformLocation extends PlatformLocation {
            constructor(_doc: any);
            readonly location: Location;
            getBaseHrefFromDOM(): string;
            onPopState(fn: LocationChangeListener): void;
            onHashChange(fn: LocationChangeListener): void;
            pathname: string;
            readonly search: string;
            readonly hash: string;
            pushState(state: any, title: string, url: string): void;
            replaceState(state: any, title: string, url: string): void;
            forward(): void;
            back(): void;
    }
}

declare module '@angular/platform-browser/browser/server-transition' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken, Provider } from '@angular/core';
    /**
        * An id that identifies a particular application being bootstrapped, that should
        * match across the client/server boundary.
        */
    export const TRANSITION_ID: InjectionToken<{}>;
    export function bootstrapListenerFactory(transitionId: string, document: any): () => void;
    export const SERVER_TRANSITION_PROVIDERS: Provider[];
}

declare module '@angular/platform-browser/browser/testability' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { GetTestability, Testability, TestabilityRegistry } from '@angular/core';
    export class BrowserGetTestability implements GetTestability {
        static init(): void;
        addToWindow(registry: TestabilityRegistry): void;
        findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;
    }
}

declare module '@angular/platform-browser/dom/dom_adapter' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Type } from '@angular/core';
    export function getDOM(): DomAdapter;
    export function setDOM(adapter: DomAdapter): void;
    export function setRootDomAdapter(adapter: DomAdapter): void;
    /**
        * Provides DOM operations in an environment-agnostic way.
        *
        * @security Tread carefully! Interacting with the DOM directly is dangerous and
        * can introduce XSS risks.
        */
    export abstract class DomAdapter {
            resourceLoaderType: Type<any>;
            abstract hasProperty(element: any, name: string): boolean;
            abstract setProperty(el: Element, name: string, value: any): any;
            abstract getProperty(el: Element, name: string): any;
            abstract invoke(el: Element, methodName: string, args: any[]): any;
            abstract logError(error: any): any;
            abstract log(error: any): any;
            abstract logGroup(error: any): any;
            abstract logGroupEnd(): any;
            /**
                * Maps attribute names to their corresponding property names for cases
                * where attribute name doesn't match property name.
                */
            attrToPropMap: {
                    [key: string]: string;
            };
            abstract contains(nodeA: any, nodeB: any): boolean;
            abstract parse(templateHtml: string): any;
            abstract querySelector(el: any, selector: string): any;
            abstract querySelectorAll(el: any, selector: string): any[];
            abstract on(el: any, evt: any, listener: any): any;
            abstract onAndCancel(el: any, evt: any, listener: any): Function;
            abstract dispatchEvent(el: any, evt: any): any;
            abstract createMouseEvent(eventType: any): any;
            abstract createEvent(eventType: string): any;
            abstract preventDefault(evt: any): any;
            abstract isPrevented(evt: any): boolean;
            abstract getInnerHTML(el: any): string;
            /** Returns content if el is a <template> element, null otherwise. */
            abstract getTemplateContent(el: any): any;
            abstract getOuterHTML(el: any): string;
            abstract nodeName(node: any): string;
            abstract nodeValue(node: any): string | null;
            abstract type(node: any): string;
            abstract content(node: any): any;
            abstract firstChild(el: any): Node | null;
            abstract nextSibling(el: any): Node | null;
            abstract parentElement(el: any): Node | null;
            abstract childNodes(el: any): Node[];
            abstract childNodesAsList(el: any): Node[];
            abstract clearNodes(el: any): any;
            abstract appendChild(el: any, node: any): any;
            abstract removeChild(el: any, node: any): any;
            abstract replaceChild(el: any, newNode: any, oldNode: any): any;
            abstract remove(el: any): Node;
            abstract insertBefore(parent: any, ref: any, node: any): any;
            abstract insertAllBefore(parent: any, ref: any, nodes: any): any;
            abstract insertAfter(parent: any, el: any, node: any): any;
            abstract setInnerHTML(el: any, value: any): any;
            abstract getText(el: any): string | null;
            abstract setText(el: any, value: string): any;
            abstract getValue(el: any): string;
            abstract setValue(el: any, value: string): any;
            abstract getChecked(el: any): boolean;
            abstract setChecked(el: any, value: boolean): any;
            abstract createComment(text: string): any;
            abstract createTemplate(html: any): HTMLElement;
            abstract createElement(tagName: any, doc?: any): HTMLElement;
            abstract createElementNS(ns: string, tagName: string, doc?: any): Element;
            abstract createTextNode(text: string, doc?: any): Text;
            abstract createScriptTag(attrName: string, attrValue: string, doc?: any): HTMLElement;
            abstract createStyleElement(css: string, doc?: any): HTMLStyleElement;
            abstract createShadowRoot(el: any): any;
            abstract getShadowRoot(el: any): any;
            abstract getHost(el: any): any;
            abstract getDistributedNodes(el: any): Node[];
            abstract clone(node: Node): Node;
            abstract getElementsByClassName(element: any, name: string): HTMLElement[];
            abstract getElementsByTagName(element: any, name: string): HTMLElement[];
            abstract classList(element: any): any[];
            abstract addClass(element: any, className: string): any;
            abstract removeClass(element: any, className: string): any;
            abstract hasClass(element: any, className: string): boolean;
            abstract setStyle(element: any, styleName: string, styleValue: string): any;
            abstract removeStyle(element: any, styleName: string): any;
            abstract getStyle(element: any, styleName: string): string;
            abstract hasStyle(element: any, styleName: string, styleValue?: string): boolean;
            abstract tagName(element: any): string;
            abstract attributeMap(element: any): Map<string, string>;
            abstract hasAttribute(element: any, attribute: string): boolean;
            abstract hasAttributeNS(element: any, ns: string, attribute: string): boolean;
            abstract getAttribute(element: any, attribute: string): string | null;
            abstract getAttributeNS(element: any, ns: string, attribute: string): string;
            abstract setAttribute(element: any, name: string, value: string): any;
            abstract setAttributeNS(element: any, ns: string, name: string, value: string): any;
            abstract removeAttribute(element: any, attribute: string): any;
            abstract removeAttributeNS(element: any, ns: string, attribute: string): any;
            abstract templateAwareRoot(el: any): any;
            abstract createHtmlDocument(): HTMLDocument;
            abstract getBoundingClientRect(el: any): any;
            abstract getTitle(doc: Document): string;
            abstract setTitle(doc: Document, newTitle: string): any;
            abstract elementMatches(n: any, selector: string): boolean;
            abstract isTemplateElement(el: any): boolean;
            abstract isTextNode(node: any): boolean;
            abstract isCommentNode(node: any): boolean;
            abstract isElementNode(node: any): boolean;
            abstract hasShadowRoot(node: any): boolean;
            abstract isShadowRoot(node: any): boolean;
            abstract importIntoDoc(node: Node): Node;
            abstract adoptNode(node: Node): Node;
            abstract getHref(element: any): string;
            abstract getEventKey(event: any): string;
            abstract resolveAndSetHref(element: any, baseUrl: string, href: string): any;
            abstract supportsDOMEvents(): boolean;
            abstract supportsNativeShadowDOM(): boolean;
            abstract getGlobalEventTarget(doc: Document, target: string): any;
            abstract getHistory(): History;
            abstract getLocation(): Location;
            abstract getBaseHref(doc: Document): string | null;
            abstract resetBaseElement(): void;
            abstract getUserAgent(): string;
            abstract setData(element: any, name: string, value: string): any;
            abstract getComputedStyle(element: any): any;
            abstract getData(element: any, name: string): string | null;
            abstract setGlobalVar(name: string, value: any): any;
            abstract supportsWebAnimation(): boolean;
            abstract performanceNow(): number;
            abstract getAnimationPrefix(): string;
            abstract getTransitionEnd(): string;
            abstract supportsAnimation(): boolean;
            abstract supportsCookies(): boolean;
            abstract getCookie(name: string): string | null;
            abstract setCookie(name: string, value: string): any;
    }
}

declare module '@angular/platform-browser/dom/dom_renderer' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { Renderer2, RendererFactory2, RendererType2 } from '@angular/core';
    import { EventManager } from '@angular/platform-browser/dom/events/event_manager';
    import { DomSharedStylesHost } from '@angular/platform-browser/dom/shared_styles_host';
    export const NAMESPACE_URIS: {
        [ns: string]: string;
    };
    export const COMPONENT_VARIABLE = "%COMP%";
    export const HOST_ATTR: string;
    export const CONTENT_ATTR: string;
    export function shimContentAttribute(componentShortId: string): string;
    export function shimHostAttribute(componentShortId: string): string;
    export function flattenStyles(compId: string, styles: Array<any | any[]>, target: string[]): string[];
    export class DomRendererFactory2 implements RendererFactory2 {
        constructor(eventManager: EventManager, sharedStylesHost: DomSharedStylesHost);
        createRenderer(element: any, type: RendererType2 | null): Renderer2;
    }
}

declare module '@angular/platform-browser/dom/events/dom_events' {
    import { EventManagerPlugin } from '@angular/platform-browser/dom/events/event_manager';
    export class DomEventsPlugin extends EventManagerPlugin {
        constructor(doc: any);
        supports(eventName: string): boolean;
        addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
    }
}

declare module '@angular/platform-browser/dom/events/key_events' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { NgZone } from '@angular/core';
    import { EventManagerPlugin } from '@angular/platform-browser/dom/events/event_manager';
    /**
        * @experimental
        */
    export class KeyEventsPlugin extends EventManagerPlugin {
            constructor(doc: any);
            supports(eventName: string): boolean;
            addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;
            static parseEventName(eventName: string): {
                    [key: string]: string;
            } | null;
            static getEventFullKey(event: KeyboardEvent): string;
            static eventCallback(fullKey: any, handler: Function, zone: NgZone): Function;
    }
}

declare module '@angular/platform-browser/dom/shared_styles_host' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { OnDestroy } from '@angular/core';
    export class SharedStylesHost {
        addStyles(styles: string[]): void;
        onStylesAdded(additions: Set<string>): void;
        getAllStyles(): string[];
    }
    export class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {
        constructor(_doc: any);
        addHost(hostNode: Node): void;
        removeHost(hostNode: Node): void;
        onStylesAdded(additions: Set<string>): void;
        ngOnDestroy(): void;
    }
}

declare module '@angular/platform-browser/browser/generic_browser_adapter' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { DomAdapter } from '@angular/platform-browser/dom/dom_adapter';
    /**
        * Provides DOM operations in any browser environment.
        *
        * @security Tread carefully! Interacting with the DOM directly is dangerous and
        * can introduce XSS risks.
        */
    export abstract class GenericBrowserDomAdapter extends DomAdapter {
            constructor();
            getDistributedNodes(el: HTMLElement): Node[];
            resolveAndSetHref(el: HTMLAnchorElement, baseUrl: string, href: string): void;
            supportsDOMEvents(): boolean;
            supportsNativeShadowDOM(): boolean;
            getAnimationPrefix(): string;
            getTransitionEnd(): string;
            supportsAnimation(): boolean;
    }
}

