// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../../rxjs/Observable
//   ../../../../rxjs/Subject

declare module '@angular/core' {
    /**
        * @module
        * @description
        * Entry point from which you should import all public core APIs.
        */
    export { Component, Directive } from '@angular/core/metadata';
    export * from '@angular/core/version';
    export { Class, ClassDefinition, TypeDecorator } from '@angular/core/util/decorators';
    export * from '@angular/core/di';
    export { createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, enableProdMode, isDevMode, createPlatformFactory, NgProbeToken } from '@angular/core/application_ref';
    export { APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER } from '@angular/core/application_tokens';
    export { APP_INITIALIZER, ApplicationInitStatus } from '@angular/core/application_init';
    export * from '@angular/core/zone';
    export * from '@angular/core/render';
    export * from '@angular/core/linker';
    export { DebugElement, DebugNode, asNativeElements, getDebugNode, Predicate } from '@angular/core/debug/debug_node';
    export { GetTestability, Testability, TestabilityRegistry, setTestabilityGetter } from '@angular/core/testability/testability';
    export * from '@angular/core/change_detection';
    export * from '@angular/core/platform_core_providers';
    export { TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID, MissingTranslationStrategy } from '@angular/core/i18n/tokens';
    export { ApplicationModule } from '@angular/core/application_module';
    export { wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, WtfScopeFn } from '@angular/core/profile/profile';
    export { Type } from '@angular/core/type';
    export { EventEmitter } from '@angular/core/event_emitter';
    export { ErrorHandler } from '@angular/core/error_handler';
    export * from '@angular/core/core_private_export';
    export { Sanitizer, SecurityContext } from '@angular/core/security';
    export * from '@angular/core/codegen_private_exports';
    export * from '@angular/core/animation/animation_metadata_wrapped';
    /**
        * @deprecated from v4
        */
    export type AnimationEntryMetadata = any;
    /**
        * @deprecated from v4
        */
    export type AnimationStateTransitionMetadata = any;
    /**
        * @deprecated from v4
        */
    export type AnimationPlayer = any;
    /**
        * @deprecated from v4
        */
    export type AnimationStyles = any;
    /**
        * @deprecated from v4
        */
    export type AnimationKeyframe = any;
}

declare module '@angular/core/metadata' {
    export * from './di'
    export * from './directives'
    export * from './lifecycle_hooks'
    export * from './ng_module'
    export * from './view'
}

declare module '@angular/core/version' {
    /**
        * @whatItDoes Represents the version of Angular
        *
        * @stable
        */
    export class Version {
            full: string;
            constructor(full: string);
            readonly major: string;
            readonly minor: string;
            readonly patch: string;
    }
    /**
        * @stable
        */
    export const VERSION: Version;
}

declare module '@angular/core/util/decorators' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Type } from '@angular/core/type';
    /**
        * Declares the interface to be used with {@link Class}.
        *
        * @stable
        */
    export type ClassDefinition = {
            /**
                * Optional argument for specifying the superclass.
                */
            extends?: Type<any>;
            /**
                * Required constructor function for a class.
                *
                * The function may be optionally wrapped in an `Array`, in which case additional parameter
                * annotations may be specified.
                * The number of arguments and the number of parameter annotations must match.
                *
                * See {@link Class} for example of usage.
                */
            constructor: Function | any[];
    } & {
            /**
                * Other methods on the class. Note that values should have type 'Function' but TS requires
                * all properties to have a narrower type than the index signature.
                */
            [x: string]: Type<any> | Function | any[];
    };
    /**
        * An interface implemented by all Angular type decorators, which allows them to be used as ES7
        * decorators as well as
        * Angular DSL syntax.
        *
        * DSL syntax:
        *
        * ```
        * var MyClass = ng
        *   .Component({...})
        *   .Class({...});
        * ```
        *
        * ES7 syntax:
        *
        * ```
        * @ng.Component({...})
        * class MyClass {...}
        * ```
        * @stable
        */
    export interface TypeDecorator {
            /**
                * Invoke as ES7 decorator.
                */
            <T extends Type<any>>(type: T): T;
            (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;
            /**
                * Storage for the accumulated annotations so far used by the DSL syntax.
                *
                * Used by {@link Class} to annotate the generated class.
                */
            annotations: any[];
            /**
                * Generate a class from the definition and annotate it with {@link TypeDecorator#annotations}.
                */
            Class(obj: ClassDefinition): Type<any>;
    }
    /**
        * Provides a way for expressing ES6 classes with parameter annotations in ES5.
        *
        * ## Basic Example
        *
        * ```
        * var Greeter = ng.Class({
        *   constructor: function(name) {
        *     this.name = name;
        *   },
        *
        *   greet: function() {
        *     alert('Hello ' + this.name + '!');
        *   }
        * });
        * ```
        *
        * is equivalent to ES6:
        *
        * ```
        * class Greeter {
        *   constructor(name) {
        *     this.name = name;
        *   }
        *
        *   greet() {
        *     alert('Hello ' + this.name + '!');
        *   }
        * }
        * ```
        *
        * or equivalent to ES5:
        *
        * ```
        * var Greeter = function (name) {
        *   this.name = name;
        * }
        *
        * Greeter.prototype.greet = function () {
        *   alert('Hello ' + this.name + '!');
        * }
        * ```
        *
        * ### Example with parameter annotations
        *
        * ```
        * var MyService = ng.Class({
        *   constructor: [String, [new Optional(), Service], function(name, myService) {
        *     ...
        *   }]
        * });
        * ```
        *
        * is equivalent to ES6:
        *
        * ```
        * class MyService {
        *   constructor(name: string, @Optional() myService: Service) {
        *     ...
        *   }
        * }
        * ```
        *
        * ### Example with inheritance
        *
        * ```
        * var Shape = ng.Class({
        *   constructor: (color) {
        *     this.color = color;
        *   }
        * });
        *
        * var Square = ng.Class({
        *   extends: Shape,
        *   constructor: function(color, size) {
        *     Shape.call(this, color);
        *     this.size = size;
        *   }
        * });
        * ```
        * @suppress {globalThis}
        * @stable
        */
    export function Class(clsDef: ClassDefinition): Type<any>;
    /**
        * @suppress {globalThis}
        */
    export function makeDecorator(name: string, props: {
            [name: string]: any;
    }, parentClass?: any, chainFn?: (fn: Function) => void): (...args: any[]) => (cls: any) => any;
    export function makeParamDecorator(name: string, props: ([string, any] | {
            [name: string]: any;
    })[], parentClass?: any): any;
    export function makePropDecorator(name: string, props: ([string, any] | {
            [key: string]: any;
    })[], parentClass?: any): any;
}

declare module '@angular/core/di' {
    export * from './forward_ref'
    export * from './injection_token'
    export * from './injector'
    export * from './metadata'
    export * from './provider'
    export * from './reflective_errors'
    export * from './reflective_injector'
    export * from './reflective_key'
    export * from './reflective_provider'
}

declare module '@angular/core/application_ref' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Observable } from 'rxjs/Observable';
    import { ErrorHandler } from '@angular/core/error_handler';
    import { ApplicationInitStatus } from '@angular/core/application_init';
    import { Console } from '@angular/core/console';
    import { InjectionToken, Injector, Provider } from '@angular/core/di';
    import { CompilerOptions } from '@angular/core/linker/compiler';
    import { ComponentFactory, ComponentRef } from '@angular/core/linker/component_factory';
    import { ComponentFactoryResolver } from '@angular/core/linker/component_factory_resolver';
    import { NgModuleFactory, NgModuleRef } from '@angular/core/linker/ng_module_factory';
    import { ViewRef } from '@angular/core/linker/view_ref';
    import { Type } from '@angular/core/type';
    import { NgZone } from '@angular/core/zone/ng_zone';
    export const ALLOW_MULTIPLE_PLATFORMS: InjectionToken<boolean>;
    /**
        * Disable Angular's development mode, which turns off assertions and other
        * checks within the framework.
        *
        * One important assertion this disables verifies that a change detection pass
        * does not result in additional changes to any bindings (also known as
        * unidirectional data flow).
        *
        * @stable
        */
    export function enableProdMode(): void;
    /**
        * Returns whether Angular is in development mode. After called once,
        * the value is locked and won't change any more.
        *
        * By default, this is true, unless a user calls `enableProdMode` before calling this.
        *
        * @experimental APIs related to application bootstrap are currently under review.
        */
    export function isDevMode(): boolean;
    /**
        * A token for third-party components that can register themselves with NgProbe.
        *
        * @experimental
        */
    export class NgProbeToken {
            name: string;
            token: any;
            constructor(name: string, token: any);
    }
    /**
        * Creates a platform.
        * Platforms have to be eagerly created via this function.
        *
        * @experimental APIs related to application bootstrap are currently under review.
        */
    export function createPlatform(injector: Injector): PlatformRef;
    /**
        * Creates a factory for a platform
        *
        * @experimental APIs related to application bootstrap are currently under review.
        */
    export function createPlatformFactory(parentPlatformFactory: ((extraProviders?: Provider[]) => PlatformRef) | null, name: string, providers?: Provider[]): (extraProviders?: Provider[]) => PlatformRef;
    /**
        * Checks that there currently is a platform which contains the given token as a provider.
        *
        * @experimental APIs related to application bootstrap are currently under review.
        */
    export function assertPlatform(requiredToken: any): PlatformRef;
    /**
        * Destroy the existing platform.
        *
        * @experimental APIs related to application bootstrap are currently under review.
        */
    export function destroyPlatform(): void;
    /**
        * Returns the current platform.
        *
        * @experimental APIs related to application bootstrap are currently under review.
        */
    export function getPlatform(): PlatformRef | null;
    /**
        * The Angular platform is the entry point for Angular on a web page. Each page
        * has exactly one platform, and services (such as reflection) which are common
        * to every Angular application running on the page are bound in its scope.
        *
        * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
        * explicitly by calling {@link createPlatform}().
        *
        * @stable
        */
    export abstract class PlatformRef {
            /**
                * Creates an instance of an `@NgModule` for the given platform
                * for offline compilation.
                *
                * ## Simple Example
                *
                * ```typescript
                * my_module.ts:
                *
                * @NgModule({
                *   imports: [BrowserModule]
                * })
                * class MyModule {}
                *
                * main.ts:
                * import {MyModuleNgFactory} from './my_module.ngfactory';
                * import {platformBrowser} from '@angular/platform-browser';
                *
                * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
                * ```
                *
                * @experimental APIs related to application bootstrap are currently under review.
                */
            abstract bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>): Promise<NgModuleRef<M>>;
            /**
                * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
                *
                * ## Simple Example
                *
                * ```typescript
                * @NgModule({
                *   imports: [BrowserModule]
                * })
                * class MyModule {}
                *
                * let moduleRef = platformBrowser().bootstrapModule(MyModule);
                * ```
                * @stable
                */
            abstract bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: CompilerOptions | CompilerOptions[]): Promise<NgModuleRef<M>>;
            /**
                * Register a listener to be called when the platform is disposed.
                */
            abstract onDestroy(callback: () => void): void;
            /**
                * Retrieve the platform {@link Injector}, which is the parent injector for
                * every Angular application on the page and provides singleton providers.
                */
            readonly abstract injector: Injector;
            /**
                * Destroy the Angular platform and all Angular applications on the page.
                */
            abstract destroy(): void;
            readonly abstract destroyed: boolean;
    }
    /**
        * workaround https://github.com/angular/tsickle/issues/350
        * @suppress {checkTypes}
        */
    export class PlatformRef_ extends PlatformRef {
            constructor(_injector: Injector);
            onDestroy(callback: () => void): void;
            readonly injector: Injector;
            readonly destroyed: boolean;
            destroy(): void;
            bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>): Promise<NgModuleRef<M>>;
            bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: CompilerOptions | CompilerOptions[]): Promise<NgModuleRef<M>>;
    }
    /**
        * A reference to an Angular application running on a page.
        *
        * For more about Angular applications, see the documentation for {@link bootstrap}.
        *
        * @stable
        */
    export abstract class ApplicationRef {
            /**
                * Bootstrap a new component at the root level of the application.
                *
                * ### Bootstrap process
                *
                * When bootstrapping a new root component into an application, Angular mounts the
                * specified application component onto DOM elements identified by the [componentType]'s
                * selector and kicks off automatic change detection to finish initializing the component.
                *
                * ### Example
                * {@example core/ts/platform/platform.ts region='longform'}
                */
            abstract bootstrap<C>(componentFactory: ComponentFactory<C> | Type<C>): ComponentRef<C>;
            /**
                * Invoke this method to explicitly process change detection and its side-effects.
                *
                * In development mode, `tick()` also performs a second change detection cycle to ensure that no
                * further changes are detected. If additional changes are picked up during this second cycle,
                * bindings in the app have side-effects that cannot be resolved in a single change detection
                * pass.
                * In this case, Angular throws an error, since an Angular application can only have one change
                * detection pass during which all change detection must complete.
                */
            abstract tick(): void;
            /**
                * Get a list of component types registered to this application.
                * This list is populated even before the component is created.
                */
            readonly abstract componentTypes: Type<any>[];
            /**
                * Get a list of components registered to this application.
                */
            readonly abstract components: ComponentRef<any>[];
            /**
                * Attaches a view so that it will be dirty checked.
                * The view will be automatically detached when it is destroyed.
                * This will throw if the view is already attached to a ViewContainer.
                */
            abstract attachView(view: ViewRef): void;
            /**
                * Detaches a view from dirty checking again.
                */
            abstract detachView(view: ViewRef): void;
            /**
                * Returns the number of attached views.
                */
            readonly abstract viewCount: number;
            /**
                * Returns an Observable that indicates when the application is stable or unstable.
                */
            readonly abstract isStable: Observable<boolean>;
    }
    /**
        * workaround https://github.com/angular/tsickle/issues/350
        * @suppress {checkTypes}
        */
    export class ApplicationRef_ extends ApplicationRef {
            constructor(_zone: NgZone, _console: Console, _injector: Injector, _exceptionHandler: ErrorHandler, _componentFactoryResolver: ComponentFactoryResolver, _initStatus: ApplicationInitStatus);
            attachView(viewRef: ViewRef): void;
            detachView(viewRef: ViewRef): void;
            bootstrap<C>(componentOrFactory: ComponentFactory<C> | Type<C>): ComponentRef<C>;
            tick(): void;
            ngOnDestroy(): void;
            readonly viewCount: number;
            readonly componentTypes: Type<any>[];
            readonly components: ComponentRef<any>[];
            readonly isStable: Observable<boolean>;
    }
}

declare module '@angular/core/application_tokens' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken } from '@angular/core/di';
    import { ComponentRef } from '@angular/core/linker/component_factory';
    /**
        * A DI Token representing a unique string id assigned to the application by Angular and used
        * primarily for prefixing application attributes and CSS styles when
        * {@link ViewEncapsulation#Emulated} is being used.
        *
        * If you need to avoid randomly generated value to be used as an application id, you can provide
        * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
        * using this token.
        * @experimental
        */
    export const APP_ID: InjectionToken<string>;
    export function _appIdRandomProviderFactory(): string;
    /**
        * Providers that will generate a random APP_ID_TOKEN.
        * @experimental
        */
    export const APP_ID_RANDOM_PROVIDER: {
            provide: InjectionToken<string>;
            useFactory: () => string;
            deps: any[];
    };
    /**
        * A function that will be executed when a platform is initialized.
        * @experimental
        */
    export const PLATFORM_INITIALIZER: InjectionToken<(() => void)[]>;
    /**
        * A token that indicates an opaque platform id.
        * @experimental
        */
    export const PLATFORM_ID: InjectionToken<Object>;
    /**
        * All callbacks provided via this token will be called for every component that is bootstrapped.
        * Signature of the callback:
        *
        * `(componentRef: ComponentRef) => void`.
        *
        * @experimental
        */
    export const APP_BOOTSTRAP_LISTENER: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;
    /**
        * A token which indicates the root directory of the application
        * @experimental
        */
    export const PACKAGE_ROOT_URL: InjectionToken<string>;
}

declare module '@angular/core/application_init' {
    import { InjectionToken } from '@angular/core/di';
    /**
        * A function that will be executed when an application is initialized.
        * @experimental
        */
    export const APP_INITIALIZER: InjectionToken<(() => void)[]>;
    /**
        * A class that reflects the state of running {@link APP_INITIALIZER}s.
        *
        * @experimental
        */
    export class ApplicationInitStatus {
            constructor(appInits: (() => any)[]);
            readonly done: boolean;
            readonly donePromise: Promise<any>;
    }
}

declare module '@angular/core/zone' {
    export * from './ng_zone'
}

declare module '@angular/core/render' {
    export * from './api'
}

declare module '@angular/core/linker' {
    export * from './compiler'
    export * from './component_factory'
    export * from './component_factory_resolver'
    export * from './element_ref'
    export * from './ng_module_factory'
    export * from './ng_module_factory_loader'
    export * from './query_list'
    export * from './system_js_ng_module_factory_loader'
    export * from './template_ref'
    export * from './view_container_ref'
    export * from './view_ref'
}

declare module '@angular/core/debug/debug_node' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Injector } from '@angular/core/di';
    import { DebugContext } from '@angular/core/view/index';
    export class EventListener {
            name: string;
            callback: Function;
            constructor(name: string, callback: Function);
    }
    /**
        * @experimental All debugging apis are currently experimental.
        */
    export class DebugNode {
            nativeNode: any;
            listeners: EventListener[];
            parent: DebugElement | null;
            constructor(nativeNode: any, parent: DebugNode | null, _debugContext: DebugContext);
            readonly injector: Injector;
            readonly componentInstance: any;
            readonly context: any;
            readonly references: {
                    [key: string]: any;
            };
            readonly providerTokens: any[];
            /**
                * @deprecated since v4
                */
            readonly source: string;
    }
    /**
        * @experimental All debugging apis are currently experimental.
        */
    export class DebugElement extends DebugNode {
            name: string;
            properties: {
                    [key: string]: any;
            };
            attributes: {
                    [key: string]: string | null;
            };
            classes: {
                    [key: string]: boolean;
            };
            styles: {
                    [key: string]: string | null;
            };
            childNodes: DebugNode[];
            nativeElement: any;
            constructor(nativeNode: any, parent: any, _debugContext: DebugContext);
            addChild(child: DebugNode): void;
            removeChild(child: DebugNode): void;
            insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]): void;
            insertBefore(refChild: DebugNode, newChild: DebugNode): void;
            query(predicate: Predicate<DebugElement>): DebugElement;
            queryAll(predicate: Predicate<DebugElement>): DebugElement[];
            queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];
            readonly children: DebugElement[];
            triggerEventHandler(eventName: string, eventObj: any): void;
    }
    /**
        * @experimental
        */
    export function asNativeElements(debugEls: DebugElement[]): any;
    /**
        * @experimental
        */
    export function getDebugNode(nativeNode: any): DebugNode | null;
    export function getAllDebugNodes(): DebugNode[];
    export function indexDebugNode(node: DebugNode): void;
    export function removeDebugNodeFromIndex(node: DebugNode): void;
    /**
        * A boolean-valued function over a value, possibly including context information
        * regarding that value's position in an array.
        *
        * @experimental All debugging apis are currently experimental.
        */
    export interface Predicate<T> {
            (value: T): boolean;
    }
}

declare module '@angular/core/testability/testability' {
    import { NgZone } from '@angular/core/zone/ng_zone';
    /**
        * Testability API.
        * `declare` keyword causes tsickle to generate externs, so these methods are
        * not renamed by Closure Compiler.
        * @experimental
        */
    export interface PublicTestability {
            isStable(): boolean;
            whenStable(callback: Function): void;
            findProviders(using: any, provider: string, exactMatch: boolean): any[];
    }
    /**
        * The Testability service provides testing hooks that can be accessed from
        * the browser and by services such as Protractor. Each bootstrapped Angular
        * application on the page will have an instance of Testability.
        * @experimental
        */
    export class Testability implements PublicTestability {
            constructor(_ngZone: NgZone);
            increasePendingRequestCount(): number;
            decreasePendingRequestCount(): number;
            isStable(): boolean;
            whenStable(callback: Function): void;
            getPendingRequestCount(): number;
            /** @deprecated use findProviders */
            findBindings(using: any, provider: string, exactMatch: boolean): any[];
            findProviders(using: any, provider: string, exactMatch: boolean): any[];
    }
    /**
        * A global registry of {@link Testability} instances for specific elements.
        * @experimental
        */
    export class TestabilityRegistry {
            constructor();
            registerApplication(token: any, testability: Testability): void;
            getTestability(elem: any): Testability | null;
            getAllTestabilities(): Testability[];
            getAllRootElements(): any[];
            findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;
    }
    /**
        * Adapter interface for retrieving the `Testability` service associated for a
        * particular context.
        *
        * @experimental Testability apis are primarily intended to be used by e2e test tool vendors like
        * the Protractor team.
        */
    export interface GetTestability {
            addToWindow(registry: TestabilityRegistry): void;
            findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;
    }
    /**
        * Set the {@link GetTestability} implementation used by the Angular testing framework.
        * @experimental
        */
    export function setTestabilityGetter(getter: GetTestability): void;
}

declare module '@angular/core/change_detection' {
    export * from './change_detection'
    export * from './change_detection_util'
    export * from './change_detector_ref'
    export * from './constants'
    export * from './pipe_transform'
}

declare module '@angular/core/platform_core_providers' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { PlatformRef } from '@angular/core/application_ref';
    import { Provider } from '@angular/core/di';
    /**
        * This platform has to be included in any other platform
        *
        * @experimental
        */
    export const platformCore: (extraProviders?: Provider[] | undefined) => PlatformRef;
}

declare module '@angular/core/i18n/tokens' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken } from '@angular/core/di/injection_token';
    /**
        * @experimental i18n support is experimental.
        */
    export const LOCALE_ID: InjectionToken<string>;
    /**
        * @experimental i18n support is experimental.
        */
    export const TRANSLATIONS: InjectionToken<string>;
    /**
        * @experimental i18n support is experimental.
        */
    export const TRANSLATIONS_FORMAT: InjectionToken<string>;
    /**
        * @experimental i18n support is experimental.
        */
    export enum MissingTranslationStrategy {
            Error = 0,
            Warning = 1,
            Ignore = 2,
    }
}

declare module '@angular/core/application_module' {
    import { ApplicationRef } from '@angular/core/application_ref';
    import { IterableDiffers, KeyValueDiffers } from '@angular/core/change_detection/change_detection';
    export function _iterableDiffersFactory(): IterableDiffers;
    export function _keyValueDiffersFactory(): KeyValueDiffers;
    export function _localeFactory(locale?: string): string;
    export function _initViewEngine(): void;
    /**
      * This module includes the providers of @angular/core that are needed
      * to bootstrap components via `ApplicationRef`.
      *
      * @experimental
      */
    export class ApplicationModule {
        constructor(appRef: ApplicationRef);
    }
}

declare module '@angular/core/profile/profile' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { WtfScopeFn } from '@angular/core/profile/wtf_impl';
    export { WtfScopeFn } from '@angular/core/profile/wtf_impl';
    /**
        * True if WTF is enabled.
        */
    export const wtfEnabled: boolean;
    /**
        * Create trace scope.
        *
        * Scopes must be strictly nested and are analogous to stack frames, but
        * do not have to follow the stack frames. Instead it is recommended that they follow logical
        * nesting. You may want to use
        * [Event
        * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
        * as they are defined in WTF.
        *
        * Used to mark scope entry. The return value is used to leave the scope.
        *
        *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
        *
        *     someMethod() {
        *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
        *        // DO SOME WORK HERE
        *        return wtfLeave(s, 123); // Return value 123
        *     }
        *
        * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
        * negatively impact the performance of your application. For this reason we recommend that
        * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
        * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
        * exception, will produce incorrect trace, but presence of exception signifies logic error which
        * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
        * an exception is expected during normal execution while profiling.
        *
        * @experimental
        */
    export const wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn;
    /**
        * Used to mark end of Scope.
        *
        * - `scope` to end.
        * - `returnValue` (optional) to be passed to the WTF.
        *
        * Returns the `returnValue for easy chaining.
        * @experimental
        */
    export const wtfLeave: <T>(scope: any, returnValue?: T) => T;
    /**
        * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
        * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
        * enabled.
        *
        *     someMethod() {
        *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
        *        var future = new Future.delay(5).then((_) {
        *          wtfEndTimeRange(s);
        *        });
        *     }
        * @experimental
        */
    export const wtfStartTimeRange: (rangeType: string, action: string) => any;
    /**
        * Ends a async time range operation.
        * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
        * enabled.
        * @experimental
        */
    export const wtfEndTimeRange: (range: any) => void;
}

declare module '@angular/core/type' {
    /**
        * @whatItDoes Represents a type that a Component or other object is instances of.
        *
        * @description
        *
        * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
        * the `MyCustomComponent` constructor function.
        *
        * @stable
        */
    export const Type: FunctionConstructor;
    export function isType(v: any): v is Type<any>;
    export interface Type<T> extends Function {
            new (...args: any[]): T;
    }
}

declare module '@angular/core/event_emitter' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Subject } from 'rxjs/Subject';
    /**
        * Use by directives and components to emit custom Events.
        *
        * ### Examples
        *
        * In the following example, `Zippy` alternatively emits `open` and `close` events when its
        * title gets clicked:
        *
        * ```
        * @Component({
        *   selector: 'zippy',
        *   template: `
        *   <div class="zippy">
        *     <div (click)="toggle()">Toggle</div>
        *     <div [hidden]="!visible">
        *       <ng-content></ng-content>
        *     </div>
        *  </div>`})
        * export class Zippy {
        *   visible: boolean = true;
        *   @Output() open: EventEmitter<any> = new EventEmitter();
        *   @Output() close: EventEmitter<any> = new EventEmitter();
        *
        *   toggle() {
        *     this.visible = !this.visible;
        *     if (this.visible) {
        *       this.open.emit(null);
        *     } else {
        *       this.close.emit(null);
        *     }
        *   }
        * }
        * ```
        *
        * The events payload can be accessed by the parameter `$event` on the components output event
        * handler:
        *
        * ```
        * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
        * ```
        *
        * Uses Rx.Observable but provides an adapter to make it work as specified here:
        * https://github.com/jhusain/observable-spec
        *
        * Once a reference implementation of the spec is available, switch to it.
        * @stable
        */
    export class EventEmitter<T> extends Subject<T> {
            __isAsync: boolean;
            /**
                * Creates an instance of [EventEmitter], which depending on [isAsync],
                * delivers events synchronously or asynchronously.
                */
            constructor(isAsync?: boolean);
            emit(value?: T): void;
            subscribe(generatorOrNext?: any, error?: any, complete?: any): any;
    }
}

declare module '@angular/core/error_handler' {
    /**
        * @whatItDoes Provides a hook for centralized exception handling.
        *
        * @description
        *
        * The default implementation of `ErrorHandler` prints error messages to the `console`. To
        * intercept error handling, write a custom exception handler that replaces this default as
        * appropriate for your app.
        *
        * ### Example
        *
        * ```
        * class MyErrorHandler implements ErrorHandler {
        *   handleError(error) {
        *     // do something with the exception
        *   }
        * }
        *
        * @NgModule({
        *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
        * })
        * class MyModule {}
        * ```
        *
        * @stable
        */
    export class ErrorHandler {
            constructor(
                    /**
                        * @deprecated since v4.0 parameter no longer has an effect, as ErrorHandler will never
                        * rethrow.
                        */
                    deprecatedParameter?: boolean);
            handleError(error: any): void;
    }
    export function wrappedError(message: string, originalError: any): Error;
}

declare module '@angular/core/core_private_export' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export { ALLOW_MULTIPLE_PLATFORMS as ɵALLOW_MULTIPLE_PLATFORMS } from '@angular/core/application_ref';
    export { APP_ID_RANDOM_PROVIDER as ɵAPP_ID_RANDOM_PROVIDER } from '@angular/core/application_tokens';
    export { ValueUnwrapper as ɵValueUnwrapper, devModeEqual as ɵdevModeEqual } from '@angular/core/change_detection/change_detection_util';
    export { isListLikeIterable as ɵisListLikeIterable } from '@angular/core/change_detection/change_detection_util';
    export { ChangeDetectorStatus as ɵChangeDetectorStatus, isDefaultChangeDetectionStrategy as ɵisDefaultChangeDetectionStrategy } from '@angular/core/change_detection/constants';
    export { Console as ɵConsole } from '@angular/core/console';
    export { ERROR_COMPONENT_TYPE as ɵERROR_COMPONENT_TYPE } from '@angular/core/errors';
    export { ComponentFactory as ɵComponentFactory } from '@angular/core/linker/component_factory';
    export { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from '@angular/core/linker/component_factory_resolver';
    export { LIFECYCLE_HOOKS_VALUES as ɵLIFECYCLE_HOOKS_VALUES, LifecycleHooks as ɵLifecycleHooks } from '@angular/core/metadata/lifecycle_hooks';
    export { ViewMetadata as ɵViewMetadata } from '@angular/core/metadata/view';
    export { Reflector as ɵReflector, reflector as ɵreflector } from '@angular/core/reflection/reflection';
    export { ReflectionCapabilities as ɵReflectionCapabilities } from '@angular/core/reflection/reflection_capabilities';
    export { ReflectorReader as ɵReflectorReader } from '@angular/core/reflection/reflector_reader';
    export { GetterFn as ɵGetterFn, MethodFn as ɵMethodFn, SetterFn as ɵSetterFn } from '@angular/core/reflection/types';
    export { DirectRenderer as ɵDirectRenderer, RenderDebugInfo as ɵRenderDebugInfo } from '@angular/core/render/api';
    export { global as ɵglobal, looseIdentical as ɵlooseIdentical, stringify as ɵstringify } from '@angular/core/util';
    export { makeDecorator as ɵmakeDecorator } from '@angular/core/util/decorators';
    export { isObservable as ɵisObservable, isPromise as ɵisPromise } from '@angular/core/util/lang';
    export { NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR } from '@angular/core/view/provider';
}

declare module '@angular/core/security' {
    /**
        * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
        * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
        * handled.
        *
        * See DomSanitizer for more details on security in Angular applications.
        *
        * @stable
        */
    export enum SecurityContext {
            NONE = 0,
            HTML = 1,
            STYLE = 2,
            SCRIPT = 3,
            URL = 4,
            RESOURCE_URL = 5,
    }
    /**
        * Sanitizer is used by the views to sanitize potentially dangerous values.
        *
        * @stable
        */
    export abstract class Sanitizer {
            abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;
    }
}

declare module '@angular/core/codegen_private_exports' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from '@angular/core/linker/component_factory_resolver';
    export { NgModuleInjector as ɵNgModuleInjector } from '@angular/core/linker/ng_module_factory';
    export { registerModuleFactory as ɵregisterModuleFactory } from '@angular/core/linker/ng_module_factory_loader';
    export { reflector as ɵreflector } from '@angular/core/reflection/reflection';
    export { ArgumentType as ɵArgumentType, BindingFlags as ɵBindingFlags, DepFlags as ɵDepFlags, EMPTY_ARRAY as ɵEMPTY_ARRAY, EMPTY_MAP as ɵEMPTY_MAP, NodeFlags as ɵNodeFlags, QueryBindingType as ɵQueryBindingType, QueryValueType as ɵQueryValueType, ViewDefinition as ɵViewDefinition, ViewFlags as ɵViewFlags, anchorDef as ɵand, createComponentFactory as ɵccf, createRendererType2 as ɵcrt, directiveDef as ɵdid, elementDef as ɵeld, elementEventFullName as ɵelementEventFullName, getComponentViewDefinitionFactory as ɵgetComponentViewDefinitionFactory, inlineInterpolate as ɵinlineInterpolate, interpolate as ɵinterpolate, ngContentDef as ɵncd, nodeValue as ɵnov, pipeDef as ɵpid, providerDef as ɵprd, pureArrayDef as ɵpad, pureObjectDef as ɵpod, purePipeDef as ɵppd, queryDef as ɵqud, textDef as ɵted, unwrapValue as ɵunv, viewDef as ɵvid } from '@angular/core/view/index';
}

declare module '@angular/core/animation/animation_metadata_wrapped' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { AnimateTimings, AnimationMetadataType } from '@angular/core/animation/dsl';
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export const AUTO_STYLE = "*";
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationMetadata {
            type: AnimationMetadataType;
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationTriggerMetadata {
            name: string;
            definitions: AnimationMetadata[];
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationStateMetadata extends AnimationMetadata {
            name: string;
            styles: AnimationStyleMetadata;
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationTransitionMetadata extends AnimationMetadata {
            expr: string | ((fromState: string, toState: string) => boolean);
            animation: AnimationMetadata | AnimationMetadata[];
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationKeyframesSequenceMetadata extends AnimationMetadata {
            steps: AnimationStyleMetadata[];
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationStyleMetadata extends AnimationMetadata {
            styles: {
                    [key: string]: string | number;
            } | {
                    [key: string]: string | number;
            }[];
            offset?: number;
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationAnimateMetadata extends AnimationMetadata {
            timings: string | number | AnimateTimings;
            styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata | null;
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationSequenceMetadata extends AnimationMetadata {
            steps: AnimationMetadata[];
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export interface AnimationGroupMetadata extends AnimationMetadata {
            steps: AnimationMetadata[];
    }
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function trigger(name: string, definitions: AnimationMetadata[]): AnimationTriggerMetadata;
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function animate(timings: string | number, styles?: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata): AnimationAnimateMetadata;
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function group(steps: AnimationMetadata[]): AnimationGroupMetadata;
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function sequence(steps: AnimationMetadata[]): AnimationSequenceMetadata;
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function style(tokens: {
            [key: string]: string | number;
    } | Array<{
            [key: string]: string | number;
    }>): AnimationStyleMetadata;
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function state(name: string, styles: AnimationStyleMetadata): AnimationStateMetadata;
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata;
    /**
        * @deprecated This symbol has moved. Please Import from @angular/animations instead!
        */
    export function transition(stateChangeExpr: string | ((fromState: string, toState: string) => boolean), steps: AnimationMetadata | AnimationMetadata[]): AnimationTransitionMetadata;
    /**
        * @deprecated This has been renamed to `AnimationEvent`. Please import it from @angular/animations.
        */
    export interface AnimationTransitionEvent {
            fromState: string;
            toState: string;
            totalTime: number;
            phaseName: string;
            element: any;
            triggerName: string;
    }
}

declare module '@angular/core/console' {
    export class Console {
        log(message: string): void;
        warn(message: string): void;
    }
}

declare module '@angular/core/linker/compiler' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken } from '@angular/core/di';
    import { MissingTranslationStrategy } from '@angular/core/i18n/tokens';
    import { ViewEncapsulation } from '@angular/core/metadata';
    import { Type } from '@angular/core/type';
    import { ComponentFactory } from '@angular/core/linker/component_factory';
    import { NgModuleFactory } from '@angular/core/linker/ng_module_factory';
    /**
        * Combination of NgModuleFactory and ComponentFactorys.
        *
        * @experimental
        */
    export class ModuleWithComponentFactories<T> {
            ngModuleFactory: NgModuleFactory<T>;
            componentFactories: ComponentFactory<any>[];
            constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);
    }
    /**
        * Low-level service for running the angular compiler during runtime
        * to create {@link ComponentFactory}s, which
        * can later be used to create and render a Component instance.
        *
        * Each `@NgModule` provides an own `Compiler` to its injector,
        * that will use the directives/pipes of the ng module for compilation
        * of components.
        * @stable
        */
    export class Compiler {
            /**
                * Compiles the given NgModule and all of its components. All templates of the components listed
                * in `entryComponents` have to be inlined.
                */
            compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
            /**
                * Compiles the given NgModule and all of its components
                */
            compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
            /**
                * Same as {@link compileModuleSync} but also creates ComponentFactories for all components.
                */
            compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
            /**
                * Same as {@link compileModuleAsync} but also creates ComponentFactories for all components.
                */
            compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
            /**
                * Exposes the CSS-style selectors that have been used in `ngContent` directives within
                * the template of the given component.
                * This is used by the `upgrade` library to compile the appropriate transclude content
                * in the AngularJS wrapper component.
                *
                * @deprecated since v4. Use ComponentFactory.ngContentSelectors instead.
                */
            getNgContentSelectors(component: Type<any>): string[];
            /**
                * Clears all caches.
                */
            clearCache(): void;
            /**
                * Clears the cache for the given component/ngModule.
                */
            clearCacheFor(type: Type<any>): void;
    }
    /**
        * Options for creating a compiler
        *
        * @experimental
        */
    export type CompilerOptions = {
            /**
                * @deprecated since v4 this option has no effect anymore.
                */
            useDebug?: boolean;
            useJit?: boolean;
            defaultEncapsulation?: ViewEncapsulation;
            providers?: any[];
            missingTranslation?: MissingTranslationStrategy;
            enableLegacyTemplate?: boolean;
    };
    /**
        * Token to provide CompilerOptions in the platform injector.
        *
        * @experimental
        */
    export const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;
    /**
        * A factory for creating a Compiler
        *
        * @experimental
        */
    export abstract class CompilerFactory {
            abstract createCompiler(options?: CompilerOptions[]): Compiler;
    }
}

declare module '@angular/core/linker/component_factory' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { ChangeDetectorRef } from '@angular/core/change_detection/change_detection';
    import { Injector } from '@angular/core/di/injector';
    import { Type } from '@angular/core/type';
    import { ElementRef } from '@angular/core/linker/element_ref';
    import { NgModuleRef } from '@angular/core/linker/ng_module_factory';
    import { ViewRef } from '@angular/core/linker/view_ref';
    /**
        * Represents an instance of a Component created via a {@link ComponentFactory}.
        *
        * `ComponentRef` provides access to the Component Instance as well other objects related to this
        * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
        * method.
        * @stable
        */
    export abstract class ComponentRef<C> {
            /**
                * Location of the Host Element of this Component Instance.
                */
            readonly abstract location: ElementRef;
            /**
                * The injector on which the component instance exists.
                */
            readonly abstract injector: Injector;
            /**
                * The instance of the Component.
                */
            readonly abstract instance: C;
            /**
                * The {@link ViewRef} of the Host View of this Component instance.
                */
            readonly abstract hostView: ViewRef;
            /**
                * The {@link ChangeDetectorRef} of the Component instance.
                */
            readonly abstract changeDetectorRef: ChangeDetectorRef;
            /**
                * The component type.
                */
            readonly abstract componentType: Type<any>;
            /**
                * Destroys the component instance and all of the data structures associated with it.
                */
            abstract destroy(): void;
            /**
                * Allows to register a callback that will be called when the component is destroyed.
                */
            abstract onDestroy(callback: Function): void;
    }
    /**
        * @stable
        */
    export abstract class ComponentFactory<C> {
            readonly abstract selector: string;
            readonly abstract componentType: Type<any>;
            /**
                * selector for all <ng-content> elements in the component.
                */
            readonly abstract ngContentSelectors: string[];
            /**
                * the inputs of the component.
                */
            readonly abstract inputs: {
                    propName: string;
                    templateName: string;
            }[];
            /**
                * the outputs of the component.
                */
            readonly abstract outputs: {
                    propName: string;
                    templateName: string;
            }[];
            /**
                * Creates a new component.
                */
            abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;
    }
}

declare module '@angular/core/linker/component_factory_resolver' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Injector } from '@angular/core/di/injector';
    import { Type } from '@angular/core/type';
    import { ComponentFactory, ComponentRef } from '@angular/core/linker/component_factory';
    import { NgModuleRef } from '@angular/core/linker/ng_module_factory';
    export function noComponentFactoryError(component: Function): Error;
    export function getComponent(error: Error): Type<any>;
    /**
        * @stable
        */
    export abstract class ComponentFactoryResolver {
            static NULL: ComponentFactoryResolver;
            abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;
    }
    export class CodegenComponentFactoryResolver implements ComponentFactoryResolver {
            constructor(factories: ComponentFactory<any>[], _parent: ComponentFactoryResolver, _ngModule: NgModuleRef<any>);
            resolveComponentFactory<T>(component: {
                    new (...args: any[]): T;
            }): ComponentFactory<T>;
    }
    export class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {
            constructor(factory: ComponentFactory<C>, ngModule: NgModuleRef<any>);
            readonly selector: string;
            readonly componentType: Type<any>;
            readonly ngContentSelectors: string[];
            readonly inputs: {
                    propName: string;
                    templateName: string;
            }[];
            readonly outputs: {
                    propName: string;
                    templateName: string;
            }[];
            create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;
    }
}

declare module '@angular/core/linker/ng_module_factory' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Injector } from '@angular/core/di/injector';
    import { Type } from '@angular/core/type';
    import { ComponentFactory } from '@angular/core/linker/component_factory';
    import { ComponentFactoryResolver } from '@angular/core/linker/component_factory_resolver';
    /**
        * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
        *
        * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
        * NgModule Instance.
        *
        * @stable
        */
    export abstract class NgModuleRef<T> {
            /**
                * The injector that contains all of the providers of the NgModule.
                */
            readonly abstract injector: Injector;
            /**
                * The ComponentFactoryResolver to get hold of the ComponentFactories
                * declared in the `entryComponents` property of the module.
                */
            readonly abstract componentFactoryResolver: ComponentFactoryResolver;
            /**
                * The NgModule instance.
                */
            readonly abstract instance: T;
            /**
                * Destroys the module instance and all of the data structures associated with it.
                */
            abstract destroy(): void;
            /**
                * Allows to register a callback that will be called when the module is destroyed.
                */
            abstract onDestroy(callback: () => void): void;
    }
    /**
        * @experimental
        */
    export class NgModuleFactory<T> {
            constructor(_injectorClass: {
                    new (parentInjector: Injector): NgModuleInjector<T>;
            }, _moduleType: Type<T>);
            readonly moduleType: Type<T>;
            create(parentInjector: Injector | null): NgModuleRef<T>;
    }
    export abstract class NgModuleInjector<T> implements Injector, NgModuleRef<T> {
            parent: Injector;
            bootstrapFactories: ComponentFactory<any>[];
            instance: T;
            constructor(parent: Injector, factories: ComponentFactory<any>[], bootstrapFactories: ComponentFactory<any>[]);
            create(): void;
            abstract createInternal(): T;
            get(token: any, notFoundValue?: any): any;
            abstract getInternal(token: any, notFoundValue: any): any;
            readonly injector: Injector;
            readonly componentFactoryResolver: ComponentFactoryResolver;
            destroy(): void;
            onDestroy(callback: () => void): void;
            abstract destroyInternal(): void;
    }
}

declare module '@angular/core/linker/view_ref' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { ApplicationRef } from '@angular/core/application_ref';
    import { ChangeDetectorRef } from '@angular/core/change_detection/change_detector_ref';
    /**
        * @stable
        */
    export abstract class ViewRef extends ChangeDetectorRef {
            /**
                * Destroys the view and all of the data structures associated with it.
                */
            abstract destroy(): void;
            readonly abstract destroyed: boolean;
            abstract onDestroy(callback: Function): any;
    }
    /**
        * Represents an Angular View.
        *
        * <!-- TODO: move the next two paragraphs to the dev guide -->
        * A View is a fundamental building block of the application UI. It is the smallest grouping of
        * Elements which are created and destroyed together.
        *
        * Properties of elements in a View can change, but the structure (number and order) of elements in
        * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
        * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
        * <!-- /TODO -->
        *
        * ### Example
        *
        * Given this template...
        *
        * ```
        * Count: {{items.length}}
        * <ul>
        *   <li *ngFor="let  item of items">{{item}}</li>
        * </ul>
        * ```
        *
        * We have two {@link TemplateRef}s:
        *
        * Outer {@link TemplateRef}:
        * ```
        * Count: {{items.length}}
        * <ul>
        *   <ng-template ngFor let-item [ngForOf]="items"></ng-template>
        * </ul>
        * ```
        *
        * Inner {@link TemplateRef}:
        * ```
        *   <li>{{item}}</li>
        * ```
        *
        * Notice that the original template is broken down into two separate {@link TemplateRef}s.
        *
        * The outer/inner {@link TemplateRef}s are then assembled into views like so:
        *
        * ```
        * <!-- ViewRef: outer-0 -->
        * Count: 2
        * <ul>
        *   <ng-template view-container-ref></ng-template>
        *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
        *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
        * </ul>
        * <!-- /ViewRef: outer-0 -->
        * ```
        * @experimental
        */
    export abstract class EmbeddedViewRef<C> extends ViewRef {
            readonly abstract context: C;
            readonly abstract rootNodes: any[];
    }
    export interface InternalViewRef extends ViewRef {
            detachFromAppRef(): void;
            attachToAppRef(appRef: ApplicationRef): void;
    }
}

declare module '@angular/core/zone/ng_zone' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { EventEmitter } from '@angular/core/event_emitter';
    /**
        * An injectable service for executing work inside or outside of the Angular zone.
        *
        * The most common use of this service is to optimize performance when starting a work consisting of
        * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
        * Angular. Such tasks can be kicked off via {@link runOutsideAngular} and if needed, these tasks
        * can reenter the Angular zone via {@link run}.
        *
        * <!-- TODO: add/fix links to:
        *   - docs explaining zones and the use of zones in Angular and change-detection
        *   - link to runOutsideAngular/run (throughout this file!)
        *   -->
        *
        * ### Example
        *
        * ```
        * import {Component, NgZone} from '@angular/core';
        * import {NgIf} from '@angular/common';
        *
        * @Component({
        *   selector: 'ng-zone-demo'.
        *   template: `
        *     <h2>Demo: NgZone</h2>
        *
        *     <p>Progress: {{progress}}%</p>
        *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
        *
        *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
        *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
        *   `,
        * })
        * export class NgZoneDemo {
        *   progress: number = 0;
        *   label: string;
        *
        *   constructor(private _ngZone: NgZone) {}
        *
        *   // Loop inside the Angular zone
        *   // so the UI DOES refresh after each setTimeout cycle
        *   processWithinAngularZone() {
        *     this.label = 'inside';
        *     this.progress = 0;
        *     this._increaseProgress(() => console.log('Inside Done!'));
        *   }
        *
        *   // Loop outside of the Angular zone
        *   // so the UI DOES NOT refresh after each setTimeout cycle
        *   processOutsideOfAngularZone() {
        *     this.label = 'outside';
        *     this.progress = 0;
        *     this._ngZone.runOutsideAngular(() => {
        *       this._increaseProgress(() => {
        *       // reenter the Angular zone and display done
        *       this._ngZone.run(() => {console.log('Outside Done!') });
        *     }}));
        *   }
        *
        *   _increaseProgress(doneCallback: () => void) {
        *     this.progress += 1;
        *     console.log(`Current progress: ${this.progress}%`);
        *
        *     if (this.progress < 100) {
        *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
        *     } else {
        *       doneCallback();
        *     }
        *   }
        * }
        * ```
        *
        * @experimental
        */
    export class NgZone {
            constructor({enableLongStackTrace}: {
                    enableLongStackTrace?: boolean;
            });
            static isInAngularZone(): boolean;
            static assertInAngularZone(): void;
            static assertNotInAngularZone(): void;
            /**
                * Executes the `fn` function synchronously within the Angular zone and returns value returned by
                * the function.
                *
                * Running functions via `run` allows you to reenter Angular zone from a task that was executed
                * outside of the Angular zone (typically started via {@link runOutsideAngular}).
                *
                * Any future tasks or microtasks scheduled from within this function will continue executing from
                * within the Angular zone.
                *
                * If a synchronous error happens it will be rethrown and not reported via `onError`.
                */
            run(fn: () => any): any;
            /**
                * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
                * rethrown.
                */
            runGuarded(fn: () => any): any;
            /**
                * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
                * the function.
                *
                * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
                * doesn't trigger Angular change-detection or is subject to Angular's error handling.
                *
                * Any future tasks or microtasks scheduled from within this function will continue executing from
                * outside of the Angular zone.
                *
                * Use {@link run} to reenter the Angular zone and do work that updates the application model.
                */
            runOutsideAngular(fn: () => any): any;
            /**
                * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
                */
            readonly onUnstable: EventEmitter<any>;
            /**
                * Notifies when there is no more microtasks enqueue in the current VM Turn.
                * This is a hint for Angular to do change detection, which may enqueue more microtasks.
                * For this reason this event can fire multiple times per VM Turn.
                */
            readonly onMicrotaskEmpty: EventEmitter<any>;
            /**
                * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
                * implies we are about to relinquish VM turn.
                * This event gets called just once.
                */
            readonly onStable: EventEmitter<any>;
            /**
                * Notify that an error has been delivered.
                */
            readonly onError: EventEmitter<any>;
            /**
                * Whether there are no outstanding microtasks or macrotasks.
                */
            readonly isStable: boolean;
            readonly hasPendingMicrotasks: boolean;
            readonly hasPendingMacrotasks: boolean;
    }
}

declare module '@angular/core/view/index' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export { anchorDef, elementDef } from '@angular/core/view/element';
    export { ngContentDef } from '@angular/core/view/ng_content';
    export { directiveDef, pipeDef, providerDef } from '@angular/core/view/provider';
    export { pureArrayDef, pureObjectDef, purePipeDef } from '@angular/core/view/pure_expression';
    export { queryDef } from '@angular/core/view/query';
    export { ViewRef_, createComponentFactory, getComponentViewDefinitionFactory, nodeValue } from '@angular/core/view/refs';
    export { initServicesIfNeeded } from '@angular/core/view/services';
    export { textDef } from '@angular/core/view/text';
    export { EMPTY_ARRAY, EMPTY_MAP, createRendererType2, elementEventFullName, inlineInterpolate, interpolate, rootRenderNodes, unwrapValue } from '@angular/core/view/util';
    export { viewDef } from '@angular/core/view/view';
    export { attachEmbeddedView, detachEmbeddedView, moveEmbeddedView } from '@angular/core/view/view_attach';
    export * from '@angular/core/view/types';
}

declare module '@angular/core/di/injection_token' {
    /**
        * Creates a token that can be used in a DI Provider.
        *
        * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
        *
        * ```typescript
        * var t = new OpaqueToken("value");
        *
        * var injector = Injector.resolveAndCreate([
        *   {provide: t, useValue: "bindingValue"}
        * ]);
        *
        * expect(injector.get(t)).toEqual("bindingValue");
        * ```
        *
        * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
        * caused by multiple providers using the same string as two different tokens.
        *
        * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
        * error messages.
        * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`
        * instead.
        */
    export class OpaqueToken {
            protected _desc: string;
            constructor(_desc: string);
            toString(): string;
    }
    /**
        * Creates a token that can be used in a DI Provider.
        *
        * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
        * runtime representation) such as when injecting an interface, callable type, array or
        * parametrized type.
        *
        * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
        * the `Injector`. This provides additional level of type safety.
        *
        * ```
        * interface MyInterface {...}
        * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
        * // myInterface is inferred to be MyInterface.
        * ```
        *
        * ### Example
        *
        * {@example core/di/ts/injector_spec.ts region='InjectionToken'}
        *
        * @stable
        */
    export class InjectionToken<T> extends OpaqueToken {
            constructor(desc: string);
            toString(): string;
    }
}

declare module '@angular/core/change_detection/change_detection' {
    import { IterableDiffers } from '@angular/core/change_detection/differs/iterable_differs';
    import { KeyValueDiffers } from '@angular/core/change_detection/differs/keyvalue_differs';
    export { SimpleChanges } from '@angular/core/metadata/lifecycle_hooks';
    export { SimpleChange, ValueUnwrapper, WrappedValue, devModeEqual } from '@angular/core/change_detection/change_detection_util';
    export { ChangeDetectorRef } from '@angular/core/change_detection/change_detector_ref';
    export { ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy } from '@angular/core/change_detection/constants';
    export { DefaultIterableDifferFactory } from '@angular/core/change_detection/differs/default_iterable_differ';
    export { DefaultIterableDiffer } from '@angular/core/change_detection/differs/default_iterable_differ';
    export { DefaultKeyValueDifferFactory } from '@angular/core/change_detection/differs/default_keyvalue_differ';
    export { CollectionChangeRecord, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, NgIterable, TrackByFn, TrackByFunction } from '@angular/core/change_detection/differs/iterable_differs';
    export { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers } from '@angular/core/change_detection/differs/keyvalue_differs';
    export { PipeTransform } from '@angular/core/change_detection/pipe_transform';
    export const defaultIterableDiffers: IterableDiffers;
    export const defaultKeyValueDiffers: KeyValueDiffers;
}

declare module '@angular/core/profile/wtf_impl' {
    /**
      * A scope function for the Web Tracing Framework (WTF).
      *
      * @experimental
      */
    export interface WtfScopeFn {
        (arg0?: any, arg1?: any): any;
    }
    export interface Range {
    }
    export interface Scope {
        (...args: any[]): any;
    }
    export function detectWTF(): boolean;
    export function createScope(signature: string, flags?: any): any;
    export function leave<T>(scope: Scope): void;
    export function leave<T>(scope: Scope, returnValue?: T): T;
    export function startTimeRange(rangeType: string, action: string): Range;
    export function endTimeRange(range: Range): void;
}

declare module '@angular/core/change_detection/change_detection_util' {
    export function devModeEqual(a: any, b: any): boolean;
    /**
        * Indicates that the result of a {@link Pipe} transformation has changed even though the
        * reference
        * has not changed.
        *
        * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
        *
        * Example:
        *
        * ```
        * if (this._latestValue === this._latestReturnedValue) {
        *    return this._latestReturnedValue;
        *  } else {
        *    this._latestReturnedValue = this._latestValue;
        *    return WrappedValue.wrap(this._latestValue); // this will force update
        *  }
        * ```
        * @stable
        */
    export class WrappedValue {
            wrapped: any;
            constructor(wrapped: any);
            static wrap(value: any): WrappedValue;
    }
    /**
        * Helper class for unwrapping WrappedValue s
        */
    export class ValueUnwrapper {
            hasWrappedValue: boolean;
            unwrap(value: any): any;
            reset(): void;
    }
    /**
        * Represents a basic change from a previous to a new value.
        * @stable
        */
    export class SimpleChange {
            previousValue: any;
            currentValue: any;
            firstChange: boolean;
            constructor(previousValue: any, currentValue: any, firstChange: boolean);
            /**
                * Check whether the new value is the first value assigned.
                */
            isFirstChange(): boolean;
    }
    export function isListLikeIterable(obj: any): boolean;
    export function areIterablesEqual(a: any, b: any, comparator: (a: any, b: any) => boolean): boolean;
    export function iterateListLike(obj: any, fn: (p: any) => any): void;
    export function isJsObject(o: any): boolean;
}

declare module '@angular/core/change_detection/constants' {
    /**
        * Describes within the change detector which strategy will be used the next time change
        * detection is triggered.
        * @stable
        */
    export enum ChangeDetectionStrategy {
            /**
                * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
                */
            OnPush = 0,
            /**
                * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
                */
            Default = 1,
    }
    /**
        * Describes the status of the detector.
        */
    export enum ChangeDetectorStatus {
            /**
                * `CheckOnce` means that after calling detectChanges the mode of the change detector
                * will become `Checked`.
                */
            CheckOnce = 0,
            /**
                * `Checked` means that the change detector should be skipped until its mode changes to
                * `CheckOnce`.
                */
            Checked = 1,
            /**
                * `CheckAlways` means that after calling detectChanges the mode of the change detector
                * will remain `CheckAlways`.
                */
            CheckAlways = 2,
            /**
                * `Detached` means that the change detector sub tree is not a part of the main tree and
                * should be skipped.
                */
            Detached = 3,
            /**
                * `Errored` means that the change detector encountered an error checking a binding
                * or calling a directive lifecycle method and is now in an inconsistent state. Change
                * detectors in this state will no longer detect changes.
                */
            Errored = 4,
            /**
                * `Destroyed` means that the change detector is destroyed.
                */
            Destroyed = 5,
    }
    export function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean;
}

declare module '@angular/core/errors' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { DebugContext } from '@angular/core/view';
    export const ERROR_TYPE = "ngType";
    export const ERROR_COMPONENT_TYPE = "ngComponentType";
    export const ERROR_DEBUG_CONTEXT = "ngDebugContext";
    export const ERROR_ORIGINAL_ERROR = "ngOriginalError";
    export const ERROR_LOGGER = "ngErrorLogger";
    export function getType(error: Error): Function;
    export function getDebugContext(error: Error): DebugContext;
    export function getOriginalError(error: Error): Error;
    export function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void;
}

declare module '@angular/core/metadata/lifecycle_hooks' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { SimpleChange } from '@angular/core/change_detection/change_detection_util';
    /**
        * @stable
        */
    export enum LifecycleHooks {
            OnInit = 0,
            OnDestroy = 1,
            DoCheck = 2,
            OnChanges = 3,
            AfterContentInit = 4,
            AfterContentChecked = 5,
            AfterViewInit = 6,
            AfterViewChecked = 7,
    }
    /**
        * A `changes` object whose keys are property names and
        * values are instances of {@link SimpleChange}. See {@link OnChanges}
        * @stable
        */
    export interface SimpleChanges {
            [propName: string]: SimpleChange;
    }
    export const LIFECYCLE_HOOKS_VALUES: LifecycleHooks[];
    /**
        * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
        *
        * @description
        * `ngOnChanges` is called right after the data-bound properties have been checked and before view
        * and content children are checked if at least one of them has changed.
        * The `changes` parameter contains the changed properties.
        *
        * See {@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface OnChanges {
            ngOnChanges(changes: SimpleChanges): void;
    }
    /**
        * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
        * initialized.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
        *
        * @description
        * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
        * first time, and before any of its children have been checked. It is invoked only once when the
        * directive is instantiated.
        *
        * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface OnInit {
            ngOnInit(): void;
    }
    /**
        * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
        *
        * @description
        * `ngDoCheck` gets called to check the changes in the directives in addition to the default
        * algorithm. The default change detection algorithm looks for differences by comparing
        * bound-property values by reference across change detection runs.
        *
        * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
        * changes on the same input, as `ngOnChanges` will continue to be called when the default change
        * detector detects changes.
        *
        * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking
        * for collections.
        *
        * See {@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface DoCheck {
            ngDoCheck(): void;
    }
    /**
        * @whatItDoes Lifecycle hook that is called when a directive, pipe or service is destroyed.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
        *
        * @description
        * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
        * instance is destroyed.
        *
        * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface OnDestroy {
            ngOnDestroy(): void;
    }
    /**
        *
        * @whatItDoes Lifecycle hook that is called after a directive's content has been fully
        * initialized.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
        *
        * @description
        * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface AfterContentInit {
            ngAfterContentInit(): void;
    }
    /**
        * @whatItDoes Lifecycle hook that is called after every check of a directive's content.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
        *
        * @description
        * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface AfterContentChecked {
            ngAfterContentChecked(): void;
    }
    /**
        * @whatItDoes Lifecycle hook that is called after a component's view has been fully
        * initialized.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
        *
        * @description
        * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface AfterViewInit {
            ngAfterViewInit(): void;
    }
    /**
        * @whatItDoes Lifecycle hook that is called after every check of a component's view.
        * @howToUse
        * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
        *
        * @description
        * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
        *
        * @stable
        */
    export interface AfterViewChecked {
            ngAfterViewChecked(): void;
    }
}

declare module '@angular/core/metadata/view' {
    /**
        * Defines template and style encapsulation options available for Component's {@link Component}.
        *
        * See {@link ViewMetadata#encapsulation}.
        * @stable
        */
    export enum ViewEncapsulation {
            /**
                * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
                * Element and pre-processing the style rules provided via
                * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
                * attribute to all selectors.
                *
                * This is the default option.
                */
            Emulated = 0,
            /**
                * Use the native encapsulation mechanism of the renderer.
                *
                * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
                * creating a ShadowRoot for Component's Host Element.
                */
            Native = 1,
            /**
                * Don't provide any template or style encapsulation.
                */
            None = 2,
    }
    /**
        * Metadata properties available for configuring Views.
        *
        * For details on the `@Component` annotation, see {@link Component}.
        *
        * ### Example
        *
        * ```
        * @Component({
        *   selector: 'greet',
        *   template: 'Hello {{name}}!',
        * })
        * class Greet {
        *   name: string;
        *
        *   constructor() {
        *     this.name = 'World';
        *   }
        * }
        * ```
        *
        * @deprecated Use Component instead.
        *
        * {@link Component}
        */
    export class ViewMetadata {
            /** {@link Component.templateUrl} */
            templateUrl: string | undefined;
            /** {@link Component.template} */
            template: string | undefined;
            /** {@link Component.stylesUrl} */
            styleUrls: string[] | undefined;
            /** {@link Component.styles} */
            styles: string[] | undefined;
            /** {@link Component.encapsulation} */
            encapsulation: ViewEncapsulation | undefined;
            /** {@link Component.animation} */
            animations: any[] | undefined;
            /** {@link Component.interpolation} */
            interpolation: [string, string] | undefined;
            constructor({templateUrl, template, encapsulation, styles, styleUrls, animations, interpolation}?: {
                    templateUrl?: string;
                    template?: string;
                    encapsulation?: ViewEncapsulation;
                    styles?: string[];
                    styleUrls?: string[];
                    animations?: any[];
                    interpolation?: [string, string];
            });
    }
}

declare module '@angular/core/reflection/reflection' {
    import { Reflector } from '@angular/core/reflection/reflector';
    export { Reflector } from '@angular/core/reflection/reflector';
    /**
      * The {@link Reflector} used internally in Angular to access metadata
      * about symbols.
      */
    export const reflector: Reflector;
}

declare module '@angular/core/reflection/reflection_capabilities' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Type } from '@angular/core/type';
    import { PlatformReflectionCapabilities } from '@angular/core/reflection/platform_reflection_capabilities';
    import { GetterFn, MethodFn, SetterFn } from '@angular/core/reflection/types';
    /**
        * Attention: This regex has to hold even if the code is minified!
        */
    export const DELEGATE_CTOR: RegExp;
    export class ReflectionCapabilities implements PlatformReflectionCapabilities {
            constructor(reflect?: any);
            isReflectionEnabled(): boolean;
            factory<T>(t: Type<T>): (args: any[]) => T;
            parameters(type: Type<any>): any[][];
            annotations(typeOrFunc: Type<any>): any[];
            propMetadata(typeOrFunc: any): {
                    [key: string]: any[];
            };
            hasLifecycleHook(type: any, lcProperty: string): boolean;
            getter(name: string): GetterFn;
            setter(name: string): SetterFn;
            method(name: string): MethodFn;
            importUri(type: any): string;
            resourceUri(type: any): string;
            resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;
            resolveEnum(enumIdentifier: any, name: string): any;
    }
}

declare module '@angular/core/reflection/reflector_reader' {
    /**
        * Provides read-only access to reflection data about symbols. Used internally by Angular
        * to power dependency injection and compilation.
        */
    export abstract class ReflectorReader {
            abstract parameters(typeOrFunc: any): any[][];
            abstract annotations(typeOrFunc: any): any[];
            abstract propMetadata(typeOrFunc: any): {
                    [key: string]: any[];
            };
            abstract importUri(typeOrFunc: any): string | null;
            abstract resourceUri(typeOrFunc: any): string;
            abstract resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;
            abstract resolveEnum(identifier: any, name: string): any;
    }
}

declare module '@angular/core/reflection/types' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export type SetterFn = (obj: any, value: any) => void;
    export type GetterFn = (obj: any) => any;
    export type MethodFn = (obj: any, args: any[]) => any;
}

declare module '@angular/core/render/api' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { InjectionToken, Injector } from '@angular/core/di';
    import { ViewEncapsulation } from '@angular/core/metadata/view';
    /**
        * @deprecated Use `RendererType2` (and `Renderer2`) instead.
        */
    export class RenderComponentType {
            id: string;
            templateUrl: string;
            slotCount: number;
            encapsulation: ViewEncapsulation;
            styles: Array<string | any[]>;
            animations: any;
            constructor(id: string, templateUrl: string, slotCount: number, encapsulation: ViewEncapsulation, styles: Array<string | any[]>, animations: any);
    }
    /**
        * @deprecated Debug info is handeled internally in the view engine now.
        */
    export abstract class RenderDebugInfo {
            readonly abstract injector: Injector;
            readonly abstract component: any;
            readonly abstract providerTokens: any[];
            readonly abstract references: {
                    [key: string]: any;
            };
            readonly abstract context: any;
            readonly abstract source: string;
    }
    /**
        * @deprecated Use the `Renderer2` instead.
        */
    export interface DirectRenderer {
            remove(node: any): void;
            appendChild(node: any, parent: any): void;
            insertBefore(node: any, refNode: any): void;
            nextSibling(node: any): any;
            parentElement(node: any): any;
    }
    /**
        * @deprecated Use the `Renderer2` instead.
        */
    export abstract class Renderer {
            abstract selectRootElement(selectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;
            abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;
            abstract createViewRoot(hostElement: any): any;
            abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;
            abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;
            abstract projectNodes(parentElement: any, nodes: any[]): void;
            abstract attachViewAfter(node: any, viewRootNodes: any[]): void;
            abstract detachView(viewRootNodes: any[]): void;
            abstract destroyView(hostElement: any, viewAllNodes: any[]): void;
            abstract listen(renderElement: any, name: string, callback: Function): Function;
            abstract listenGlobal(target: string, name: string, callback: Function): Function;
            abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;
            abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string): void;
            /**
                * Used only in debug mode to serialize property changes to dom nodes as attributes.
                */
            abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void;
            abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;
            abstract setElementStyle(renderElement: any, styleName: string, styleValue: string): void;
            abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;
            abstract setText(renderNode: any, text: string): void;
            abstract animate(element: any, startingStyles: any, keyframes: any[], duration: number, delay: number, easing: string, previousPlayers?: any[]): any;
    }
    export const Renderer2Interceptor: InjectionToken<Renderer2[]>;
    /**
        * Injectable service that provides a low-level interface for modifying the UI.
        *
        * Use this service to bypass Angular's templating and make custom UI changes that can't be
        * expressed declaratively. For example if you need to set a property or an attribute whose name is
        * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
        * respectively.
        *
        * If you are implementing a custom renderer, you must implement this interface.
        *
        * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
        *
        * @deprecated Use `RendererFactory2` instead.
        */
    export abstract class RootRenderer {
            abstract renderComponent(componentType: RenderComponentType): Renderer;
    }
    /**
        * @experimental
        */
    export interface RendererType2 {
            id: string;
            encapsulation: ViewEncapsulation;
            styles: (string | any[])[];
            data: {
                    [kind: string]: any;
            };
    }
    /**
        * @experimental
        */
    export abstract class RendererFactory2 {
            abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;
    }
    /**
        * @experimental
        */
    export enum RendererStyleFlags2 {
            Important = 1,
            DashCase = 2,
    }
    /**
        * @experimental
        */
    export abstract class Renderer2 {
            /**
                * This field can be used to store arbitrary data on this renderer instance.
                * This is useful for renderers that delegate to other renderers.
                */
            readonly abstract data: {
                    [key: string]: any;
            };
            abstract destroy(): void;
            abstract createElement(name: string, namespace?: string | null): any;
            abstract createComment(value: string): any;
            abstract createText(value: string): any;
            /**
                * This property is allowed to be null / undefined,
                * in which case the view engine won't call it.
                * This is used as a performance optimization for production mode.
                */
            destroyNode: ((node: any) => void) | null;
            abstract appendChild(parent: any, newChild: any): void;
            abstract insertBefore(parent: any, newChild: any, refChild: any): void;
            abstract removeChild(parent: any, oldChild: any): void;
            abstract selectRootElement(selectorOrNode: string | any): any;
            /**
                * Attention: On WebWorkers, this will always return a value,
                * as we are asking for a result synchronously. I.e.
                * the caller can't rely on checking whether this is null or not.
                */
            abstract parentNode(node: any): any;
            /**
                * Attention: On WebWorkers, this will always return a value,
                * as we are asking for a result synchronously. I.e.
                * the caller can't rely on checking whether this is null or not.
                */
            abstract nextSibling(node: any): any;
            abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;
            abstract removeAttribute(el: any, name: string, namespace?: string | null): void;
            abstract addClass(el: any, name: string): void;
            abstract removeClass(el: any, name: string): void;
            abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;
            abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;
            abstract setProperty(el: any, name: string, value: any): void;
            abstract setValue(node: any, value: string): void;
            abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;
    }
}

declare module '@angular/core/util' {
    export * from './decorators'
    export * from './lang'
}

declare module '@angular/core/util/lang' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Observable } from 'rxjs/Observable';
    /**
        * Determine if the argument is shaped like a Promise
        */
    export function isPromise(obj: any): obj is Promise<any>;
    /**
        * Determine if the argument is an Observable
        */
    export function isObservable(obj: any | Observable<any>): obj is Observable<any>;
}

declare module '@angular/core/view/provider' {
    import { BindingDef, DepDef, DepFlags, NodeDef, NodeFlags, OutputDef, QueryValueType, ViewData } from '@angular/core/view/types';
    export function directiveDef(flags: NodeFlags, matchedQueries: [string | number, QueryValueType][], childCount: number, ctor: any, deps: ([DepFlags, any] | any)[], props?: {
        [name: string]: [number, string];
    }, outputs?: {
        [name: string]: string;
    }): NodeDef;
    export function pipeDef(flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef;
    export function providerDef(flags: NodeFlags, matchedQueries: [string | number, QueryValueType][], token: any, value: any, deps: ([DepFlags, any] | any)[]): NodeDef;
    export function _def(flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][] | null, childCount: number, token: any, value: any, deps: ([DepFlags, any] | any)[], bindings?: BindingDef[], outputs?: OutputDef[]): NodeDef;
    export function createProviderInstance(view: ViewData, def: NodeDef): any;
    export function createPipeInstance(view: ViewData, def: NodeDef): any;
    export function createDirectiveInstance(view: ViewData, def: NodeDef): any;
    export function checkAndUpdateDirectiveInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
    export function checkAndUpdateDirectiveDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
    export const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: {};
    export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;
    export function callLifecycleHooksChildrenFirst(view: ViewData, lifecycles: NodeFlags): void;
}

declare module '@angular/core/linker/ng_module_factory_loader' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { NgModuleFactory } from '@angular/core/linker/ng_module_factory';
    /**
        * Used to load ng module factories.
        * @stable
        */
    export abstract class NgModuleFactoryLoader {
            abstract load(path: string): Promise<NgModuleFactory<any>>;
    }
    /**
        * Registers a loaded module. Should only be called from generated NgModuleFactory code.
        * @experimental
        */
    export function registerModuleFactory(id: string, factory: NgModuleFactory<any>): void;
    export function clearModulesForTest(): void;
    /**
        * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
        * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
        * cannot be found.
        * @experimental
        */
    export function getModuleFactory(id: string): NgModuleFactory<any>;
}

declare module '@angular/core/animation/dsl' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    export interface ɵStyleData {
            [key: string]: string | number;
    }
    /**
        * @experimental Animation support is experimental.
        */
    export type AnimateTimings = {
            duration: number;
            delay: number;
            easing: string | null;
    };
    /**
        * @experimental Animation support is experimental.
        */
    export const enum AnimationMetadataType {
            State = 0,
            Transition = 1,
            Sequence = 2,
            Group = 3,
            Animate = 4,
            KeyframeSequence = 5,
            Style = 6,
    }
    /**
        * @experimental Animation support is experimental.
        */
    export const AUTO_STYLE = "*";
    /**
        * @experimental Animation support is experimental.
        */
    export interface AnimationMetadata {
            type: AnimationMetadataType;
    }
    /**
        * @experimental Animation support is experimental.
        */
    export interface AnimationTriggerMetadata {
            name: string;
            definitions: AnimationMetadata[];
    }
    /**
        * Metadata representing the entry of animations. Instances of this class are provided via the
        * animation DSL when the {@link state state animation function} is called.
        *
        * @experimental Animation support is experimental.
        */
    export interface AnimationStateMetadata extends AnimationMetadata {
            name: string;
            styles: AnimationStyleMetadata;
    }
    /**
        * Metadata representing the entry of animations. Instances of this class are provided via the
        * animation DSL when the {@link transition transition animation function} is called.
        *
        * @experimental Animation support is experimental.
        */
    export interface AnimationTransitionMetadata extends AnimationMetadata {
            expr: string | ((fromState: string, toState: string) => boolean);
            animation: AnimationMetadata | AnimationMetadata[];
    }
    /**
        * Metadata representing the entry of animations. Instances of this class are provided via the
        * animation DSL when the {@link keyframes keyframes animation function} is called.
        *
        * @experimental Animation support is experimental.
        */
    export interface AnimationKeyframesSequenceMetadata extends AnimationMetadata {
            steps: AnimationStyleMetadata[];
    }
    /**
        * Metadata representing the entry of animations. Instances of this class are provided via the
        * animation DSL when the {@link style style animation function} is called.
        *
        * @experimental Animation support is experimental.
        */
    export interface AnimationStyleMetadata extends AnimationMetadata {
            styles: {
                    [key: string]: string | number;
            } | {
                    [key: string]: string | number;
            }[];
            offset?: number;
    }
    /**
        * Metadata representing the entry of animations. Instances of this class are provided via the
        * animation DSL when the {@link animate animate animation function} is called.
        *
        * @experimental Animation support is experimental.
        */
    export interface AnimationAnimateMetadata extends AnimationMetadata {
            timings: string | number | AnimateTimings;
            styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata | null;
    }
    /**
        * Metadata representing the entry of animations. Instances of this class are provided via the
        * animation DSL when the {@link sequence sequence animation function} is called.
        *
        * @experimental Animation support is experimental.
        */
    export interface AnimationSequenceMetadata extends AnimationMetadata {
            steps: AnimationMetadata[];
    }
    /**
        * Metadata representing the entry of animations. Instances of this class are provided via the
        * animation DSL when the {@link group group animation function} is called.
        *
        * @experimental Animation support is experimental.
        */
    export interface AnimationGroupMetadata extends AnimationMetadata {
            steps: AnimationMetadata[];
    }
    /**
        * `trigger` is an animation-specific function that is designed to be used inside of Angular's
     animation DSL language. If this information is new, please navigate to the {@link
     Component#animations-anchor component animations metadata page} to gain a better understanding of
     how animations in Angular are used.
        *
        * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
     transition transition} entries that will be evaluated when the expression bound to the trigger
     changes.
        *
        * Triggers are registered within the component annotation data under the {@link
     Component#animations-anchor animations section}. An animation trigger can be placed on an element
     within a template by referencing the name of the trigger followed by the expression value that the
     trigger is bound to (in the form of `[@triggerName]="expression"`.
        *
        * ### Usage
        *
        * `trigger` will create an animation trigger reference based on the provided `name` value. The
     provided `animation` value is expected to be an array consisting of {@link state state} and {@link
     transition transition} declarations.
        *
        * ```typescript
        * @Component({
        *   selector: 'my-component',
        *   templateUrl: 'my-component-tpl.html',
        *   animations: [
        *     trigger("myAnimationTrigger", [
        *       state(...),
        *       state(...),
        *       transition(...),
        *       transition(...)
        *     ])
        *   ]
        * })
        * class MyComponent {
        *   myStatusExp = "something";
        * }
        * ```
        *
        * The template associated with this component will make use of the `myAnimationTrigger` animation
     trigger by binding to an element within its template code.
        *
        * ```html
        * <!-- somewhere inside of my-component-tpl.html -->
        * <div [@myAnimationTrigger]="myStatusExp">...</div>
     tools/gulp-tasks/validate-commit-message.js ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function trigger(name: string, definitions: AnimationMetadata[]): AnimationTriggerMetadata;
    /**
        * `animate` is an animation-specific function that is designed to be used inside of Angular's
        * animation DSL language. If this information is new, please navigate to the {@link
        * Component#animations-anchor component animations metadata page} to gain a better understanding of
        * how animations in Angular are used.
        *
        * `animate` specifies an animation step that will apply the provided `styles` data for a given
        * amount of time based on the provided `timing` expression value. Calls to `animate` are expected
        * to be used within {@link sequence an animation sequence}, {@link group group}, or {@link
        * transition transition}.
        *
        * ### Usage
        *
        * The `animate` function accepts two input parameters: `timing` and `styles`:
        *
        * - `timing` is a string based value that can be a combination of a duration with optional delay
        * and easing values. The format for the expression breaks down to `duration delay easing`
        * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
        * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the
        * `duration` value in millisecond form.
        * - `styles` is the style input data which can either be a call to {@link style style} or {@link
        * keyframes keyframes}. If left empty then the styles from the destination state will be collected
        * and used (this is useful when describing an animation step that will complete an animation by
        * {@link transition#the-final-animate-call animating to the final state}).
        *
        * ```typescript
        * // various functions for specifying timing data
        * animate(500, style(...))
        * animate("1s", style(...))
        * animate("100ms 0.5s", style(...))
        * animate("5s ease", style(...))
        * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
        *
        * // either style() of keyframes() can be used
        * animate(500, style({ background: "red" }))
        * animate(500, keyframes([
        *   style({ background: "blue" })),
        *   style({ background: "red" }))
        * ])
        * ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function animate(timings: string | number, styles?: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata | null): AnimationAnimateMetadata;
    /**
        * `group` is an animation-specific function that is designed to be used inside of Angular's
        * animation DSL language. If this information is new, please navigate to the {@link
        * Component#animations-anchor component animations metadata page} to gain a better understanding of
        * how animations in Angular are used.
        *
        * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are
        * useful when a series of styles must be animated/closed off at different statrting/ending times.
        *
        * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
        * transition} and it will only continue to the next instruction once all of the inner animation
        * steps have completed.
        *
        * ### Usage
        *
        * The `steps` data that is passed into the `group` animation function can either consist of {@link
        * style style} or {@link animate animate} function calls. Each call to `style()` or `animate()`
        * within a group will be executed instantly (use {@link keyframes keyframes} or a {@link
        * animate#usage animate() with a delay value} to offset styles to be applied at a later time).
        *
        * ```typescript
        * group([
        *   animate("1s", { background: "black" }))
        *   animate("2s", { color: "white" }))
        * ])
        * ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function group(steps: AnimationMetadata[]): AnimationGroupMetadata;
    /**
        * `sequence` is an animation-specific function that is designed to be used inside of Angular's
        * animation DSL language. If this information is new, please navigate to the {@link
        * Component#animations-anchor component animations metadata page} to gain a better understanding of
        * how animations in Angular are used.
        *
        * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by
        * default when an array is passed as animation data into {@link transition transition}.)
        *
        * The `sequence` function can either be used within a {@link group group} or a {@link transition
        * transition} and it will only continue to the next instruction once each of the inner animation
        * steps have completed.
        *
        * To perform animation styling in parallel with other animation steps then have a look at the
        * {@link group group} animation function.
        *
        * ### Usage
        *
        * The `steps` data that is passed into the `sequence` animation function can either consist of
        * {@link style style} or {@link animate animate} function calls. A call to `style()` will apply the
        * provided styling data immediately while a call to `animate()` will apply its styling data over a
        * given time depending on its timing data.
        *
        * ```typescript
        * sequence([
        *   style({ opacity: 0 })),
        *   animate("1s", { opacity: 1 }))
        * ])
        * ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function sequence(steps: AnimationMetadata[]): AnimationSequenceMetadata;
    /**
        * `style` is an animation-specific function that is designed to be used inside of Angular's
        * animation DSL language. If this information is new, please navigate to the {@link
        * Component#animations-anchor component animations metadata page} to gain a better understanding of
        * how animations in Angular are used.
        *
        * `style` declares a key/value object containing CSS properties/styles that can then be used for
        * {@link state animation states}, within an {@link sequence animation sequence}, or as styling data
        * for both {@link animate animate} and {@link keyframes keyframes}.
        *
        * ### Usage
        *
        * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs
        * to be defined.
        *
        * ```typescript
        * // string values are used for css properties
        * style({ background: "red", color: "blue" })
        *
        * // numerical (pixel) values are also supported
        * style({ width: 100, height: 0 })
        * ```
        *
        * #### Auto-styles (using `*`)
        *
        * When an asterix (`*`) character is used as a value then it will be detected from the element
        * being animated and applied as animation data when the animation starts.
        *
        * This feature proves useful for a state depending on layout and/or environment factors; in such
        * cases the styles are calculated just before the animation starts.
        *
        * ```typescript
        * // the steps below will animate from 0 to the
        * // actual height of the element
        * style({ height: 0 }),
        * animate("1s", style({ height: "*" }))
        * ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function style(tokens: {
            [key: string]: string | number;
    } | Array<{
            [key: string]: string | number;
    }>): AnimationStyleMetadata;
    /**
        * `state` is an animation-specific function that is designed to be used inside of Angular's
        * animation DSL language. If this information is new, please navigate to the {@link
        * Component#animations-anchor component animations metadata page} to gain a better understanding of
        * how animations in Angular are used.
        *
        * `state` declares an animation state within the given trigger. When a state is active within a
        * component then its associated styles will persist on the element that the trigger is attached to
        * (even when the animation ends).
        *
        * To animate between states, have a look at the animation {@link transition transition} DSL
        * function. To register states to an animation trigger please have a look at the {@link trigger
        * trigger} function.
        *
        * #### The `void` state
        *
        * The `void` state value is a reserved word that angular uses to determine when the element is not
        * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
        * associated element is void).
        *
        * #### The `*` (default) state
        *
        * The `*` state (when styled) is a fallback state that will be used if the state that is being
        * animated is not declared within the trigger.
        *
        * ### Usage
        *
        * `state` will declare an animation state with its associated styles
        * within the given trigger.
        *
        * - `stateNameExpr` can be one or more state names separated by commas.
        * - `styles` refers to the {@link style styling data} that will be persisted on the element once
        * the state has been reached.
        *
        * ```typescript
        * // "void" is a reserved name for a state and is used to represent
        * // the state in which an element is detached from from the application.
        * state("void", style({ height: 0 }))
        *
        * // user-defined states
        * state("closed", style({ height: 0 }))
        * state("open, visible", style({ height: "*" }))
        * ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function state(name: string, styles: AnimationStyleMetadata): AnimationStateMetadata;
    /**
        * `keyframes` is an animation-specific function that is designed to be used inside of Angular's
        * animation DSL language. If this information is new, please navigate to the {@link
        * Component#animations-anchor component animations metadata page} to gain a better understanding of
        * how animations in Angular are used.
        *
        * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
        * by an `offset` value.
        *
        * ### Usage
        *
        * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
        * animation function. Instead of applying animations from where they are currently to their
        * destination, keyframes can describe how each style entry is applied and at what point within the
        * animation arc (much like CSS Keyframe Animations do).
        *
        * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at what
        * percentage of the animate time the styles will be applied.
        *
        * ```typescript
        * // the provided offset values describe when each backgroundColor value is applied.
        * animate("5s", keyframes([
        *   style({ backgroundColor: "red", offset: 0 }),
        *   style({ backgroundColor: "blue", offset: 0.2 }),
        *   style({ backgroundColor: "orange", offset: 0.3 }),
        *   style({ backgroundColor: "black", offset: 1 })
        * ]))
        * ```
        *
        * Alternatively, if there are no `offset` values used within the style entries then the offsets
        * will be calculated automatically.
        *
        * ```typescript
        * animate("5s", keyframes([
        *   style({ backgroundColor: "red" }) // offset = 0
        *   style({ backgroundColor: "blue" }) // offset = 0.33
        *   style({ backgroundColor: "orange" }) // offset = 0.66
        *   style({ backgroundColor: "black" }) // offset = 1
        * ]))
        * ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata;
    /**
        * `transition` is an animation-specific function that is designed to be used inside of Angular's
        * animation DSL language. If this information is new, please navigate to the {@link
        * Component#animations-anchor component animations metadata page} to gain a better understanding of
        * how animations in Angular are used.
        *
        * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
        * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>
        * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting
        * and/or ending state).
        *
        * A function can also be provided as the `stateChangeExpr` argument for a transition and this
        * function will be executed each time a state change occurs. If the value returned within the
        * function is true then the associated animation will be run.
        *
        * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
        * to animate to a state value and persist its styles then one or more {@link state animation
        * states} is expected to be defined.
        *
        * ### Usage
        *
        * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
        * what the previous state is and what the current state has become. In other words, if a transition
        * is defined that matches the old/current state criteria then the associated animation will be
        * triggered.
        *
        * ```typescript
        * // all transition/state changes are defined within an animation trigger
        * trigger("myAnimationTrigger", [
        *   // if a state is defined then its styles will be persisted when the
        *   // animation has fully completed itself
        *   state("on", style({ background: "green" })),
        *   state("off", style({ background: "grey" })),
        *
        *   // a transition animation that will be kicked off when the state value
        *   // bound to "myAnimationTrigger" changes from "on" to "off"
        *   transition("on => off", animate(500)),
        *
        *   // it is also possible to do run the same animation for both directions
        *   transition("on <=> off", animate(500)),
        *
        *   // or to define multiple states pairs separated by commas
        *   transition("on => off, off => void", animate(500)),
        *
        *   // this is a catch-all state change for when an element is inserted into
        *   // the page and the destination state is unknown
        *   transition("void => *", [
        *     style({ opacity: 0 }),
        *     animate(500)
        *   ]),
        *
        *   // this will capture a state change between any states
        *   transition("* => *", animate("1s 0s")),
        *
        *   // you can also go full out and include a function
        *   transition((fromState, toState) => {
        *     // when `true` then it will allow the animation below to be invoked
        *     return fromState == "off" && toState == "on";
        *   }, animate("1s 0s"))
        * ])
        * ```
        *
        * The template associated with this component will make use of the `myAnimationTrigger` animation
        * trigger by binding to an element within its template code.
        *
        * ```html
        * <!-- somewhere inside of my-component-tpl.html -->
        * <div [@myAnimationTrigger]="myStatusExp">...</div>
        * ```
        *
        * #### The final `animate` call
        *
        * If the final step within the transition steps is a call to `animate()` that **only** uses a
        * timing value with **no style data** then it will be automatically used as the final animation arc
        * for the element to animate itself to the final state. This involves an automatic mix of
        * adding/removing CSS styles so that the element will be in the exact state it should be for the
        * applied state to be presented correctly.
        *
        * ```
        * // start off by hiding the element, but make sure that it animates properly to whatever state
        * // is currently active for "myAnimationTrigger"
        * transition("void => *", [
        *   style({ opacity: 0 }),
        *   animate(500)
        * ])
        * ```
        *
        * ### Transition Aliases (`:enter` and `:leave`)
        *
        * Given that enter (insertion) and leave (removal) animations are so common, the `transition`
        * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*
        * => void` state changes.
        *
        * ```
        * transition(":enter", [
        *   style({ opacity: 0 }),
        *   animate(500, style({ opacity: 1 }))
        * ])
        * transition(":leave", [
        *   animate(500, style({ opacity: 0 }))
        * ])
        * ```
        *
        * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
        *
        * @experimental Animation support is experimental.
        */
    export function transition(stateChangeExpr: string | ((fromState: string, toState: string) => boolean), steps: AnimationMetadata | AnimationMetadata[]): AnimationTransitionMetadata;
}

declare module '@angular/core/di/injector' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Type } from '@angular/core/type';
    import { InjectionToken } from '@angular/core/di/injection_token';
    export const THROW_IF_NOT_FOUND: Object;
    /**
        * @whatItDoes Injector interface
        * @howToUse
        * ```
        * const injector: Injector = ...;
        * injector.get(...);
        * ```
        *
        * @description
        * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
        *
        * ### Example
        *
        * {@example core/di/ts/injector_spec.ts region='Injector'}
        *
        * `Injector` returns itself when given `Injector` as a token:
        * {@example core/di/ts/injector_spec.ts region='injectInjector'}
        *
        * @stable
        */
    export abstract class Injector {
            static THROW_IF_NOT_FOUND: Object;
            static NULL: Injector;
            /**
                * Retrieves an instance from the injector based on the provided token.
                * If not found:
                * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
                * Injector.THROW_IF_NOT_FOUND is given
                * - Returns the `notFoundValue` otherwise
                */
            abstract get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T): T;
            /**
                * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>
                * @suppress {duplicate}
                */
            abstract get(token: any, notFoundValue?: any): any;
    }
}

declare module '@angular/core/linker/element_ref' {
    /**
        * A wrapper around a native element inside of a View.
        *
        * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
        * element.
        *
        * @security Permitting direct access to the DOM can make your application more vulnerable to
        * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
        * [Security Guide](http://g.co/ng/security).
        *
        * @stable
        */
    export class ElementRef {
            /**
                * The underlying native element or `null` if direct access to native elements is not supported
                * (e.g. when the application runs in a web worker).
                *
                * <div class="callout is-critical">
                *   <header>Use with caution</header>
                *   <p>
                *    Use this API as the last resort when direct access to DOM is needed. Use templating and
                *    data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer}
                *    which provides API that can safely be used even when direct access to native elements is not
                *    supported.
                *   </p>
                *   <p>
                *    Relying on direct DOM access creates tight coupling between your application and rendering
                *    layers which will make it impossible to separate the two and deploy your application into a
                *    web worker.
                *   </p>
                * </div>
                * @stable
                */
            nativeElement: any;
            constructor(nativeElement: any);
    }
}

declare module '@angular/core/change_detection/change_detector_ref' {
    /**
        * @stable
        */
    export abstract class ChangeDetectorRef {
            /**
                * Marks all {@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
                *
                * <!-- TODO: Add a link to a chapter on OnPush components -->
                *
                * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
                *
                * ```typescript
                * @Component({
                *   selector: 'cmp',
                *   changeDetection: ChangeDetectionStrategy.OnPush,
                *   template: `Number of ticks: {{numberOfTicks}}`
                * })
                * class Cmp {
                *   numberOfTicks = 0;
                *
                *   constructor(ref: ChangeDetectorRef) {
                *     setInterval(() => {
                *       this.numberOfTicks ++
                *       // the following is required, otherwise the view will not be updated
                *       this.ref.markForCheck();
                *     }, 1000);
                *   }
                * }
                *
                * @Component({
                *   selector: 'app',
                *   changeDetection: ChangeDetectionStrategy.OnPush,
                *   template: `
                *     <cmp><cmp>
                *   `,
                * })
                * class App {
                * }
                * ```
                */
            abstract markForCheck(): void;
            /**
                * Detaches the change detector from the change detector tree.
                *
                * The detached change detector will not be checked until it is reattached.
                *
                * This can also be used in combination with {@link ChangeDetectorRef#detectChanges} to implement
                * local change
                * detection checks.
                *
                * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
                * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
                *
                * ### Example
                *
                * The following example defines a component with a large list of readonly data.
                * Imagine the data changes constantly, many times per second. For performance reasons,
                * we want to check and update the list every five seconds. We can do that by detaching
                * the component's change detector and doing a local check every five seconds.
                *
                * ```typescript
                * class DataProvider {
                *   // in a real application the returned data will be different every time
                *   get data() {
                *     return [1,2,3,4,5];
                *   }
                * }
                *
                * @Component({
                *   selector: 'giant-list',
                *   template: `
                *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
                *   `,
                * })
                * class GiantList {
                *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
                *     ref.detach();
                *     setInterval(() => {
                *       this.ref.detectChanges();
                *     }, 5000);
                *   }
                * }
                *
                * @Component({
                *   selector: 'app',
                *   providers: [DataProvider],
                *   template: `
                *     <giant-list><giant-list>
                *   `,
                * })
                * class App {
                * }
                * ```
                */
            abstract detach(): void;
            /**
                * Checks the change detector and its children.
                *
                * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement local
                * change detection
                * checks.
                *
                * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
                * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
                *
                * ### Example
                *
                * The following example defines a component with a large list of readonly data.
                * Imagine, the data changes constantly, many times per second. For performance reasons,
                * we want to check and update the list every five seconds.
                *
                * We can do that by detaching the component's change detector and doing a local change detection
                * check
                * every five seconds.
                *
                * See {@link ChangeDetectorRef#detach} for more information.
                */
            abstract detectChanges(): void;
            /**
                * Checks the change detector and its children, and throws if any changes are detected.
                *
                * This is used in development mode to verify that running change detection doesn't introduce
                * other changes.
                */
            abstract checkNoChanges(): void;
            /**
                * Reattach the change detector to the change detector tree.
                *
                * This also marks OnPush ancestors as to be checked. This reattached change detector will be
                * checked during the next change detection run.
                *
                * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
                *
                * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
                *
                * The following example creates a component displaying `live` data. The component will detach
                * its change detector from the main change detector tree when the component's live property
                * is set to false.
                *
                * ```typescript
                * class DataProvider {
                *   data = 1;
                *
                *   constructor() {
                *     setInterval(() => {
                *       this.data = this.data * 2;
                *     }, 500);
                *   }
                * }
                *
                * @Component({
                *   selector: 'live-data',
                *   inputs: ['live'],
                *   template: 'Data: {{dataProvider.data}}'
                * })
                * class LiveData {
                *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
                *
                *   set live(value) {
                *     if (value)
                *       this.ref.reattach();
                *     else
                *       this.ref.detach();
                *   }
                * }
                *
                * @Component({
                *   selector: 'app',
                *   providers: [DataProvider],
                *   template: `
                *     Live Update: <input type="checkbox" [(ngModel)]="live">
                *     <live-data [live]="live"><live-data>
                *   `,
                * })
                * class App {
                *   live = true;
                * }
                * ```
                */
            abstract reattach(): void;
    }
}

declare module '@angular/core/view/element' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { RendererType2 } from '@angular/core/render/api';
    import { SecurityContext } from '@angular/core/security';
    import { BindingFlags, ElementData, ElementHandleEventFn, NodeDef, NodeFlags, QueryValueType, ViewData, ViewDefinitionFactory } from '@angular/core/view/types';
    export function anchorDef(flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][], ngContentIndex: number, childCount: number, handleEvent?: ElementHandleEventFn, templateFactory?: ViewDefinitionFactory): NodeDef;
    export function elementDef(flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][], ngContentIndex: number, childCount: number, namespaceAndName: string, fixedAttrs?: [string, string][], bindings?: [BindingFlags, string, string | SecurityContext][], outputs?: ([string, string])[], handleEvent?: ElementHandleEventFn, componentView?: ViewDefinitionFactory, componentRendererType?: RendererType2 | null): NodeDef;
    export function createElement(view: ViewData, renderHost: any, def: NodeDef): ElementData;
    export function listenToElementOutputs(view: ViewData, compView: ViewData, def: NodeDef, el: any): void;
    export function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
    export function checkAndUpdateElementDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
}

declare module '@angular/core/view/ng_content' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { NodeDef, ViewData } from '@angular/core/view/types';
    export function ngContentDef(ngContentIndex: number, index: number): NodeDef;
    export function appendNgContent(view: ViewData, renderHost: any, def: NodeDef): void;
}

declare module '@angular/core/view/pure_expression' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { NodeDef, PureExpressionData, ViewData } from '@angular/core/view/types';
    export function purePipeDef(argCount: number): NodeDef;
    export function pureArrayDef(argCount: number): NodeDef;
    export function pureObjectDef(propertyNames: string[]): NodeDef;
    export function createPureExpression(view: ViewData, def: NodeDef): PureExpressionData;
    export function checkAndUpdatePureExpressionInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
    export function checkAndUpdatePureExpressionDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
}

declare module '@angular/core/view/query' {
    import { QueryList } from '@angular/core/linker/query_list';
    import { NodeDef, NodeFlags, QueryBindingType, QueryValueType, ViewData } from '@angular/core/view/types';
    export function queryDef(flags: NodeFlags, id: number, bindings: {
        [propName: string]: QueryBindingType;
    }): NodeDef;
    export function createQuery(): QueryList<any>;
    export function dirtyParentQueries(view: ViewData): void;
    export function checkAndUpdateQuery(view: ViewData, nodeDef: NodeDef): void;
    export function getQueryValue(view: ViewData, nodeDef: NodeDef, queryValueType: QueryValueType): any;
}

declare module '@angular/core/view/refs' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { ApplicationRef } from '@angular/core/application_ref';
    import { ChangeDetectorRef } from '@angular/core/change_detection/change_detection';
    import { Injector } from '@angular/core/di';
    import { ComponentFactory } from '@angular/core/linker/component_factory';
    import { ViewContainerRef } from '@angular/core/linker/view_container_ref';
    import { EmbeddedViewRef, InternalViewRef } from '@angular/core/linker/view_ref';
    import { Renderer as RendererV1 } from '@angular/core/render/api';
    import { Type } from '@angular/core/type';
    import { ElementData, NodeDef, TemplateData, ViewContainerData, ViewData, ViewDefinitionFactory } from '@angular/core/view/types';
    export function createComponentFactory(selector: string, componentType: Type<any>, viewDefFactory: ViewDefinitionFactory, inputs: {
        [propName: string]: string;
    } | null, outputs: {
        [propName: string]: string;
    }, ngContentSelectors: string[]): ComponentFactory<any>;
    export function getComponentViewDefinitionFactory(componentFactory: ComponentFactory<any>): ViewDefinitionFactory;
    export function createViewContainerData(view: ViewData, elDef: NodeDef, elData: ElementData): ViewContainerData;
    export function createChangeDetectorRef(view: ViewData): ChangeDetectorRef;
    export class ViewRef_ implements EmbeddedViewRef<any>, InternalViewRef {
        constructor(_view: ViewData);
        readonly rootNodes: any[];
        readonly context: any;
        readonly destroyed: boolean;
        markForCheck(): void;
        detach(): void;
        detectChanges(): void;
        checkNoChanges(): void;
        reattach(): void;
        onDestroy(callback: Function): void;
        destroy(): void;
        detachFromAppRef(): void;
        attachToAppRef(appRef: ApplicationRef): void;
        attachToViewContainerRef(vcRef: ViewContainerRef): void;
    }
    export function createTemplateData(view: ViewData, def: NodeDef): TemplateData;
    export function createInjector(view: ViewData, elDef: NodeDef): Injector;
    export function nodeValue(view: ViewData, index: number): any;
    export function createRendererV1(view: ViewData): RendererV1;
}

declare module '@angular/core/view/services' {
    import { DebugContext } from '@angular/core/view/types';
    export function initServicesIfNeeded(): void;
    export function getCurrentDebugContext(): DebugContext | null;
}

declare module '@angular/core/view/text' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { NodeDef, TextData, ViewData } from '@angular/core/view/types';
    export function textDef(ngContentIndex: number, constants: string[]): NodeDef;
    export function createText(view: ViewData, renderHost: any, def: NodeDef): TextData;
    export function checkAndUpdateTextInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
    export function checkAndUpdateTextDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
}

declare module '@angular/core/view/util' {
    import { ViewEncapsulation } from '@angular/core/metadata/view';
    import { RendererType2 } from '@angular/core/render/api';
    import { BindingDef, BindingFlags, ElementData, NodeDef, QueryValueType, ViewData, ViewDefinition, ViewDefinitionFactory } from '@angular/core/view/types';
    export const NOOP: any;
    export function tokenKey(token: any): string;
    export function unwrapValue(view: ViewData, nodeIdx: number, bindingIdx: number, value: any): any;
    export function createRendererType2(values: {
        styles: (string | any[])[];
        encapsulation: ViewEncapsulation;
        data: {
            [kind: string]: any[];
        };
    }): RendererType2;
    export function resolveRendererType2(type?: RendererType2 | null): RendererType2 | null;
    export function checkBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;
    export function checkAndUpdateBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;
    export function checkBindingNoChanges(view: ViewData, def: NodeDef, bindingIdx: number, value: any): void;
    export function markParentViewsForCheck(view: ViewData): void;
    export function dispatchEvent(view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;
    export function declaredViewContainer(view: ViewData): ElementData | null;
    /**
      * for component views, this is the host element.
      * for embedded views, this is the index of the parent node
      * that contains the view container.
      */
    export function viewParentEl(view: ViewData): NodeDef | null;
    export function renderNode(view: ViewData, def: NodeDef): any;
    export function elementEventFullName(target: string | null, name: string): string;
    export function isComponentView(view: ViewData): boolean;
    export function isEmbeddedView(view: ViewData): boolean;
    export function filterQueryId(queryId: number): number;
    export function splitMatchedQueriesDsl(matchedQueriesDsl: [string | number, QueryValueType][] | null): {
        matchedQueries: {
            [queryId: string]: QueryValueType;
        };
        references: {
            [refId: string]: QueryValueType;
        };
        matchedQueryIds: number;
    };
    export function getParentRenderElement(view: ViewData, renderHost: any, def: NodeDef): any;
    export function resolveViewDefinition(factory: ViewDefinitionFactory): ViewDefinition;
    export function rootRenderNodes(view: ViewData): any[];
    export const enum RenderNodeAction {
        Collect = 0,
        AppendChild = 1,
        InsertBefore = 2,
        RemoveChild = 3,
    }
    export function visitRootRenderNodes(view: ViewData, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;
    export function visitSiblingRenderNodes(view: ViewData, action: RenderNodeAction, startIndex: number, endIndex: number, parentNode: any, nextSibling: any, target?: any[]): void;
    export function visitProjectedRenderNodes(view: ViewData, ngContentIndex: number, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;
    export function splitNamespace(name: string): string[];
    export function calcBindingFlags(bindings: BindingDef[]): BindingFlags;
    export function interpolate(valueCount: number, constAndInterp: string[]): string;
    export function inlineInterpolate(valueCount: number, c0: string, a1: any, c1: string, a2?: any, c2?: string, a3?: any, c3?: string, a4?: any, c4?: string, a5?: any, c5?: string, a6?: any, c6?: string, a7?: any, c7?: string, a8?: any, c8?: string, a9?: any, c9?: string): string;
    export const EMPTY_ARRAY: any[];
    export const EMPTY_MAP: {
        [key: string]: any;
    };
}

declare module '@angular/core/view/view' {
    import { ArgumentType, NodeDef, RootData, ViewData, ViewDefinition, ViewFlags, ViewUpdateFn } from '@angular/core/view/types';
    export function viewDef(flags: ViewFlags, nodes: NodeDef[], updateDirectives?: ViewUpdateFn, updateRenderer?: ViewUpdateFn): ViewDefinition;
    export function createEmbeddedView(parent: ViewData, anchorDef: NodeDef, context?: any): ViewData;
    export function createRootView(root: RootData, def: ViewDefinition, context?: any): ViewData;
    export function checkNoChangesView(view: ViewData): void;
    export function checkAndUpdateView(view: ViewData): void;
    export function checkAndUpdateNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): boolean;
    export function checkNoChangesNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;
    export function destroyView(view: ViewData): void;
}

declare module '@angular/core/view/view_attach' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { ElementData, ViewData } from '@angular/core/view/types';
    export function attachEmbeddedView(parentView: ViewData, elementData: ElementData, viewIndex: number | undefined | null, view: ViewData): void;
    export function detachEmbeddedView(elementData: ElementData, viewIndex?: number): ViewData | null;
    export function moveEmbeddedView(elementData: ElementData, oldViewIndex: number, newViewIndex: number): ViewData;
    export function renderDetachView(view: ViewData): void;
}

declare module '@angular/core/view/types' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Injector } from '@angular/core/di';
    import { NgModuleRef } from '@angular/core/linker/ng_module_factory';
    import { QueryList } from '@angular/core/linker/query_list';
    import { TemplateRef } from '@angular/core/linker/template_ref';
    import { ViewContainerRef } from '@angular/core/linker/view_container_ref';
    import { Renderer2, RendererFactory2, RendererType2 } from '@angular/core/render/api';
    import { Sanitizer, SecurityContext } from '@angular/core/security';
    export interface ViewDefinition {
            factory: ViewDefinitionFactory | null;
            flags: ViewFlags;
            updateDirectives: ViewUpdateFn;
            updateRenderer: ViewUpdateFn;
            handleEvent: ViewHandleEventFn;
            /**
                * Order: Depth first.
                * Especially providers are before elements / anchors.
                */
            nodes: NodeDef[];
            /** aggregated NodeFlags for all nodes **/
            nodeFlags: NodeFlags;
            rootNodeFlags: NodeFlags;
            lastRenderRootNode: NodeDef | null;
            bindingCount: number;
            outputCount: number;
            /**
                * Binary or of all query ids that are matched by one of the nodes.
                * This includes query ids from templates as well.
                * Used as a bloom filter.
                */
            nodeMatchedQueries: number;
    }
    /**
        * Factory for ViewDefinitions.
        * We use a function so we can reexeute it in case an error happens and use the given logger
        * function to log the error from the definition of the node, which is shown in all browser
        * logs.
        */
    export interface ViewDefinitionFactory {
            (logger: NodeLogger): ViewDefinition;
    }
    /**
        * Function to call console.error at the right source location. This is an indirection
        * via another function as browser will log the location that actually called
        * `console.error`.
        */
    export interface NodeLogger {
            (): () => void;
    }
    export interface ViewUpdateFn {
            (check: NodeCheckFn, view: ViewData): void;
    }
    export interface NodeCheckFn {
            (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Dynamic, values: any[]): any;
            (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Inline, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;
    }
    export const enum ArgumentType {
            Inline = 0,
            Dynamic = 1,
    }
    export interface ViewHandleEventFn {
            (view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;
    }
    /**
        * Bitmask for ViewDefintion.flags.
        */
    export const enum ViewFlags {
            None = 0,
            OnPush = 2,
    }
    /**
        * A node definition in the view.
        *
        * Note: We use one type for all nodes so that loops that loop over all nodes
        * of a ViewDefinition stay monomorphic!
        */
    export interface NodeDef {
            flags: NodeFlags;
            index: number;
            parent: NodeDef | null;
            renderParent: NodeDef | null;
            /** this is checked against NgContentDef.index to find matched nodes */
            ngContentIndex: number;
            /** number of transitive children */
            childCount: number;
            /** aggregated NodeFlags for all transitive children (does not include self) **/
            childFlags: NodeFlags;
            /** aggregated NodeFlags for all direct children (does not include self) **/
            directChildFlags: NodeFlags;
            bindingIndex: number;
            bindings: BindingDef[];
            bindingFlags: BindingFlags;
            outputIndex: number;
            outputs: OutputDef[];
            /**
                * references that the user placed on the element
                */
            references: {
                    [refId: string]: QueryValueType;
            };
            /**
                * ids and value types of all queries that are matched by this node.
                */
            matchedQueries: {
                    [queryId: number]: QueryValueType;
            };
            /** Binary or of all matched query ids of this node. */
            matchedQueryIds: number;
            /**
                * Binary or of all query ids that are matched by one of the children.
                * This includes query ids from templates as well.
                * Used as a bloom filter.
                */
            childMatchedQueries: number;
            element: ElementDef | null;
            provider: ProviderDef | null;
            text: TextDef | null;
            query: QueryDef | null;
            ngContent: NgContentDef | null;
    }
    /**
        * Bitmask for NodeDef.flags.
        * Naming convention:
        * - `Type...`: flags that are mutually exclusive
        * - `Cat...`: union of multiple `Type...` (short for category).
        */
    export const enum NodeFlags {
            None = 0,
            TypeElement = 1,
            TypeText = 2,
            CatRenderNode = 3,
            TypeNgContent = 4,
            TypePipe = 8,
            TypePureArray = 16,
            TypePureObject = 32,
            TypePurePipe = 64,
            CatPureExpression = 112,
            TypeValueProvider = 128,
            TypeClassProvider = 256,
            TypeFactoryProvider = 512,
            TypeUseExistingProvider = 1024,
            LazyProvider = 2048,
            PrivateProvider = 4096,
            TypeDirective = 8192,
            Component = 16384,
            CatProvider = 10112,
            OnInit = 32768,
            OnDestroy = 65536,
            DoCheck = 131072,
            OnChanges = 262144,
            AfterContentInit = 524288,
            AfterContentChecked = 1048576,
            AfterViewInit = 2097152,
            AfterViewChecked = 4194304,
            EmbeddedViews = 8388608,
            ComponentView = 16777216,
            TypeContentQuery = 33554432,
            TypeViewQuery = 67108864,
            StaticQuery = 134217728,
            DynamicQuery = 268435456,
            CatQuery = 100663296,
            Types = 100673535,
    }
    export interface BindingDef {
            flags: BindingFlags;
            ns: string | null;
            name: string | null;
            nonMinifiedName: string | null;
            securityContext: SecurityContext | null;
            suffix: string | null;
    }
    export const enum BindingFlags {
            TypeElementAttribute = 1,
            TypeElementClass = 2,
            TypeElementStyle = 4,
            TypeProperty = 8,
            SyntheticProperty = 16,
            SyntheticHostProperty = 32,
            CatSyntheticProperty = 48,
            Types = 15,
    }
    export interface OutputDef {
            type: OutputType;
            target: 'window' | 'document' | 'body' | 'component' | null;
            eventName: string;
            propName: string | null;
    }
    export const enum OutputType {
            ElementOutput = 0,
            DirectiveOutput = 1,
    }
    export const enum QueryValueType {
            ElementRef = 0,
            RenderElement = 1,
            TemplateRef = 2,
            ViewContainerRef = 3,
            Provider = 4,
    }
    export interface ElementDef {
            name: string | null;
            ns: string | null;
            /** ns, name, value */
            attrs: [string, string, string][] | null;
            template: ViewDefinition | null;
            componentProvider: NodeDef | null;
            componentRendererType: RendererType2 | null;
            componentView: ViewDefinitionFactory | null;
            /**
                * visible public providers for DI in the view,
                * as see from this element. This does not include private providers.
                */
            publicProviders: {
                    [tokenKey: string]: NodeDef;
            } | null;
            /**
                * same as visiblePublicProviders, but also includes private providers
                * that are located on this element.
                */
            allProviders: {
                    [tokenKey: string]: NodeDef;
            } | null;
            handleEvent: ElementHandleEventFn | null;
    }
    export interface ElementHandleEventFn {
            (view: ViewData, eventName: string, event: any): boolean;
    }
    export interface ProviderDef {
            token: any;
            tokenKey: string;
            value: any;
            deps: DepDef[];
    }
    export interface DepDef {
            flags: DepFlags;
            token: any;
            tokenKey: string;
    }
    /**
        * Bitmask for DI flags
        */
    export const enum DepFlags {
            None = 0,
            SkipSelf = 1,
            Optional = 2,
            Value = 8,
    }
    export interface TextDef {
            prefix: string;
    }
    export interface QueryDef {
            id: number;
            filterId: number;
            bindings: QueryBindingDef[];
    }
    export interface QueryBindingDef {
            propName: string;
            bindingType: QueryBindingType;
    }
    export const enum QueryBindingType {
            First = 0,
            All = 1,
    }
    export interface NgContentDef {
            /**
                * this index is checked against NodeDef.ngContentIndex to find the nodes
                * that are matched by this ng-content.
                * Note that a NodeDef with an ng-content can be reprojected, i.e.
                * have a ngContentIndex on its own.
                */
            index: number;
    }
    /**
        * View instance data.
        * Attention: Adding fields to this is performance sensitive!
        */
    export interface ViewData {
            def: ViewDefinition;
            root: RootData;
            renderer: Renderer2;
            parentNodeDef: NodeDef | null;
            parent: ViewData | null;
            viewContainerParent: ViewData | null;
            component: any;
            context: any;
            nodes: {
                    [key: number]: NodeData;
            };
            state: ViewState;
            oldValues: any[];
            disposables: DisposableFn[] | null;
    }
    /**
        * Bitmask of states
        */
    export const enum ViewState {
            FirstCheck = 1,
            ChecksEnabled = 2,
            Errored = 4,
            Destroyed = 8,
    }
    export interface DisposableFn {
            (): void;
    }
    /**
        * Node instance data.
        *
        * We have a separate type per NodeType to save memory
        * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)
        *
        * To keep our code monomorphic,
        * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).
        * This way, no usage site can get a `NodeData` from view.nodes and then use it for different
        * purposes.
        */
    export class NodeData {
    }
    /**
        * Data for an instantiated NodeType.Text.
        *
        * Attention: Adding fields to this is performance sensitive!
        */
    export interface TextData {
            renderText: any;
    }
    /**
        * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
        */
    export function asTextData(view: ViewData, index: number): TextData;
    /**
        * Data for an instantiated NodeType.Element.
        *
        * Attention: Adding fields to this is performance sensitive!
        */
    export interface ElementData {
            renderElement: any;
            componentView: ViewData;
            viewContainer: ViewContainerData | null;
            template: TemplateData;
    }
    export interface ViewContainerData extends ViewContainerRef {
            _embeddedViews: ViewData[];
    }
    export interface TemplateData extends TemplateRef<any> {
            _projectedViews: ViewData[];
    }
    /**
        * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
        */
    export function asElementData(view: ViewData, index: number): ElementData;
    /**
        * Data for an instantiated NodeType.Provider.
        *
        * Attention: Adding fields to this is performance sensitive!
        */
    export interface ProviderData {
            instance: any;
    }
    /**
        * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
        */
    export function asProviderData(view: ViewData, index: number): ProviderData;
    /**
        * Data for an instantiated NodeType.PureExpression.
        *
        * Attention: Adding fields to this is performance sensitive!
        */
    export interface PureExpressionData {
            value: any;
    }
    /**
        * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
        */
    export function asPureExpressionData(view: ViewData, index: number): PureExpressionData;
    /**
        * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
        */
    export function asQueryList(view: ViewData, index: number): QueryList<any>;
    export interface RootData {
            injector: Injector;
            ngModule: NgModuleRef<any>;
            projectableNodes: any[][];
            selectorOrNode: any;
            renderer: Renderer2;
            rendererFactory: RendererFactory2;
            sanitizer: Sanitizer;
    }
    export abstract class DebugContext {
            readonly abstract view: ViewData;
            readonly abstract nodeIndex: number | null;
            readonly abstract injector: Injector;
            readonly abstract component: any;
            readonly abstract providerTokens: any[];
            readonly abstract references: {
                    [key: string]: any;
            };
            readonly abstract context: any;
            readonly abstract componentRenderElement: any;
            readonly abstract renderNode: any;
            abstract logError(console: Console, ...values: any[]): void;
    }
    export const enum CheckType {
            CheckAndUpdate = 0,
            CheckNoChanges = 1,
    }
    export interface Services {
            setCurrentNode(view: ViewData, nodeIndex: number): void;
            createRootView(injector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any, def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData;
            createEmbeddedView(parent: ViewData, anchorDef: NodeDef, context?: any): ViewData;
            checkAndUpdateView(view: ViewData): void;
            checkNoChangesView(view: ViewData): void;
            destroyView(view: ViewData): void;
            resolveDep(view: ViewData, elDef: NodeDef | null, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;
            createDebugContext(view: ViewData, nodeIndex: number): DebugContext;
            handleEvent: ViewHandleEventFn;
            updateDirectives: (view: ViewData, checkType: CheckType) => void;
            updateRenderer: (view: ViewData, checkType: CheckType) => void;
            dirtyParentQueries: (view: ViewData) => void;
    }
    /**
        * This object is used to prevent cycles in the source files and to have a place where
        * debug mode can hook it. It is lazily filled when `isDevMode` is known.
        */
    export const Services: Services;
}

declare module '@angular/core/change_detection/differs/iterable_differs' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Provider } from '@angular/core/di';
    import { ChangeDetectorRef } from '@angular/core/change_detection/change_detector_ref';
    /**
        * A type describing supported interable types.
        *
        * @stable
        */
    export type NgIterable<T> = Array<T> | Iterable<T>;
    /**
        * A strategy for tracking changes over time to an iterable. Used by {@link NgFor} to
        * respond to changes in an iterable by effecting equivalent changes in the DOM.
        *
        * @stable
        */
    export interface IterableDiffer<V> {
            /**
                * Compute a difference between the previous state and the new `object` state.
                *
                * @param object containing the new value.
                * @returns an object describing the difference. The return value is only valid until the next
                * `diff()` invocation.
                */
            diff(object: NgIterable<V>): IterableChanges<V> | null;
    }
    /**
        * An object describing the changes in the `Iterable` collection since last time
        * `IterableDiffer#diff()` was invoked.
        *
        * @stable
        */
    export interface IterableChanges<V> {
            /**
                * Iterate over all changes. `IterableChangeRecord` will contain information about changes
                * to each item.
                */
            forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;
            /**
                * Iterate over a set of operations which when applied to the original `Iterable` will produce the
                * new `Iterable`.
                *
                * NOTE: These are not necessarily the actual operations which were applied to the original
                * `Iterable`, rather these are a set of computed operations which may not be the same as the
                * ones applied.
                *
                * @param record A change which needs to be applied
                * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the
                *        original `Iterable` location, where as `previousIndex` refers to the transient location
                *        of the item, after applying the operations up to this point.
                * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the
                *        original `Iterable` location, where as `currentIndex` refers to the transient location
                *        of the item, after applying the operations up to this point.
                */
            forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number, currentIndex: number) => void): void;
            /**
                * Iterate over changes in the order of original `Iterable` showing where the original items
                * have moved.
                */
            forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;
            /** Iterate over all added items. */
            forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;
            /** Iterate over all moved items. */
            forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
            /** Iterate over all removed items. */
            forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
            /** Iterate over all items which had their identity (as computed by the `trackByFn`) changed. */
            forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;
    }
    /**
        * Record representing the item change information.
        *
        * @stable
        */
    export interface IterableChangeRecord<V> {
            /** Current index of the item in `Iterable` or null if removed. */
            readonly currentIndex: number | null;
            /** Previous index of the item in `Iterable` or null if added. */
            readonly previousIndex: number | null;
            /** The item. */
            readonly item: V;
            /** Track by identity as computed by the `trackByFn`. */
            readonly trackById: any;
    }
    /**
        * @deprecated v4.0.0 - Use IterableChangeRecord instead.
        */
    export interface CollectionChangeRecord<V> extends IterableChangeRecord<V> {
    }
    /**
        * Nolonger used.
        *
        * @deprecated v4.0.0 - Use TrackByFunction instead
        */
    export interface TrackByFn {
            (index: number, item: any): any;
    }
    /**
        * An optional function passed into {@link NgForOf} that defines how to track
        * items in an iterable (e.g. fby index or id)
        *
        * @stable
        */
    export interface TrackByFunction<T> {
            (index: number, item: T): any;
    }
    /**
        * Provides a factory for {@link IterableDiffer}.
        *
        * @stable
        */
    export interface IterableDifferFactory {
            supports(objects: any): boolean;
            create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;
            /**
                * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
                */
            create<V>(_cdr?: ChangeDetectorRef | TrackByFunction<V>, trackByFn?: TrackByFunction<V>): IterableDiffer<V>;
    }
    /**
        * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
        * @stable
        */
    export class IterableDiffers {
            /**
                * @deprecated v4.0.0 - Should be private
                */
            factories: IterableDifferFactory[];
            constructor(factories: IterableDifferFactory[]);
            static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;
            /**
                * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
                * inherited {@link IterableDiffers} instance with the provided factories and return a new
                * {@link IterableDiffers} instance.
                *
                * The following example shows how to extend an existing list of factories,
                * which will only be applied to the injector for this component and its children.
                * This step is all that's required to make a new {@link IterableDiffer} available.
                *
                * ### Example
                *
                * ```
                * @Component({
                *   viewProviders: [
                *     IterableDiffers.extend([new ImmutableListDiffer()])
                *   ]
                * })
                * ```
                */
            static extend(factories: IterableDifferFactory[]): Provider;
            find(iterable: any): IterableDifferFactory;
    }
    export function getTypeNameForDebugging(type: any): string;
}

declare module '@angular/core/change_detection/differs/keyvalue_differs' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Provider } from '@angular/core/di';
    import { ChangeDetectorRef } from '@angular/core/change_detection/change_detector_ref';
    /**
        * A differ that tracks changes made to an object over time.
        *
        * @stable
        */
    export interface KeyValueDiffer<K, V> {
            /**
                * Compute a difference between the previous state and the new `object` state.
                *
                * @param object containing the new value.
                * @returns an object describing the difference. The return value is only valid until the next
                * `diff()` invocation.
                */
            diff(object: Map<K, V>): KeyValueChanges<K, V>;
            /**
                * Compute a difference between the previous state and the new `object` state.
                *
                * @param object containing the new value.
                * @returns an object describing the difference. The return value is only valid until the next
                * `diff()` invocation.
                */
            diff(object: {
                    [key: string]: V;
            }): KeyValueChanges<string, V>;
    }
    /**
        * An object describing the changes in the `Map` or `{[k:string]: string}` since last time
        * `KeyValueDiffer#diff()` was invoked.
        *
        * @stable
        */
    export interface KeyValueChanges<K, V> {
            /**
                * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes
                * to each item.
                */
            forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            /**
                * Iterate over changes in the order of original Map showing where the original items
                * have moved.
                */
            forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            /**
                * Iterate over all keys for which values have changed.
                */
            forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            /**
                * Iterate over all added items.
                */
            forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            /**
                * Iterate over all removed items.
                */
            forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    }
    /**
        * Record representing the item change information.
        *
        * @stable
        */
    export interface KeyValueChangeRecord<K, V> {
            /**
                * Current key in the Map.
                */
            readonly key: K;
            /**
                * Current value for the key or `null` if removed.
                */
            readonly currentValue: V | null;
            /**
                * Previous value for the key or `null` if added.
                */
            readonly previousValue: V | null;
    }
    /**
        * Provides a factory for {@link KeyValueDiffer}.
        *
        * @stable
        */
    export interface KeyValueDifferFactory {
            /**
                * Test to see if the differ knows how to diff this kind of object.
                */
            supports(objects: any): boolean;
            /**
                * Create a `KeyValueDiffer`.
                */
            create<K, V>(): KeyValueDiffer<K, V>;
            /**
                * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
                */
            create<K, V>(_cdr?: ChangeDetectorRef): KeyValueDiffer<K, V>;
    }
    /**
        * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
        * @stable
        */
    export class KeyValueDiffers {
            /**
                * @deprecated v4.0.0 - Should be private.
                */
            factories: KeyValueDifferFactory[];
            constructor(factories: KeyValueDifferFactory[]);
            static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;
            /**
                * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
                * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
                * {@link KeyValueDiffers} instance.
                *
                * The following example shows how to extend an existing list of factories,
                            * which will only be applied to the injector for this component and its children.
                            * This step is all that's required to make a new {@link KeyValueDiffer} available.
                *
                * ### Example
                *
                * ```
                * @Component({
                *   viewProviders: [
                *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
                *   ]
                * })
                * ```
                */
            static extend<S>(factories: KeyValueDifferFactory[]): Provider;
            find(kv: any): KeyValueDifferFactory;
    }
}

declare module '@angular/core/change_detection/differs/default_iterable_differ' {
    import { IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, NgIterable, TrackByFunction } from '@angular/core/change_detection/differs/iterable_differs';
    export class DefaultIterableDifferFactory implements IterableDifferFactory {
            constructor();
            supports(obj: Object | null | undefined): boolean;
            create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V>;
    }
    /**
        * @deprecated v4.0.0 - Should not be part of public API.
        */
    export class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {
            constructor(trackByFn?: TrackByFunction<V>);
            readonly collection: V[] | Iterable<V> | null;
            readonly length: number;
            forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;
            forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;
            forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;
            forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
            forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
            forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
            forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;
            diff(collection: NgIterable<V>): DefaultIterableDiffer<V> | null;
            onDestroy(): void;
            check(collection: NgIterable<V>): boolean;
            readonly isDirty: boolean;
            toString(): string;
    }
    /**
        * @stable
        */
    export class IterableChangeRecord_<V> implements IterableChangeRecord<V> {
            item: V;
            trackById: any;
            currentIndex: number | null;
            previousIndex: number | null;
            constructor(item: V, trackById: any);
            toString(): string;
    }
}

declare module '@angular/core/change_detection/differs/default_keyvalue_differ' {
    import { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory } from '@angular/core/change_detection/differs/keyvalue_differs';
    export class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {
            constructor();
            supports(obj: any): boolean;
            create<K, V>(): DefaultKeyValueDiffer<K, V>;
    }
    export class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {
            readonly isDirty: boolean;
            forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
            diff(map?: Map<any, any> | {
                    [k: string]: any;
            } | null): any;
            onDestroy(): void;
            /**
                * Check the current state of the map vs the previous.
                * The algorithm is optimised for when the keys do no change.
                */
            check(map: Map<any, any> | {
                    [k: string]: any;
            }): boolean;
            toString(): string;
    }
}

declare module '@angular/core/change_detection/pipe_transform' {
    /**
        * To create a Pipe, you must implement this interface.
        *
        * Angular invokes the `transform` method with the value of a binding
        * as the first argument, and any parameters as the second argument in list form.
        *
        * ## Syntax
        *
        * `value | pipeName[:arg0[:arg1...]]`
        *
        * ### Example ([live demo](http://plnkr.co/edit/f5oyIked9M2cKzvZNKHV?p=preview))
        *
        * The `RepeatPipe` below repeats the value as many times as indicated by the first argument:
        *
        * ```
        * import {Pipe, PipeTransform} from '@angular/core';
        *
        * @Pipe({name: 'repeat'})
        * export class RepeatPipe implements PipeTransform {
        *   transform(value: any, times: number) {
        *     return value.repeat(times);
        *   }
        * }
        * ```
        *
        * Invoking `{{ 'ok' | repeat:3 }}` in a template produces `okokok`.
        *
        * @stable
        */
    export interface PipeTransform {
            transform(value: any, ...args: any[]): any;
    }
}

declare module '@angular/core/view' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    export { anchorDef, elementDef } from '@angular/core/view/element';
    export { ngContentDef } from '@angular/core/view/ng_content';
    export { directiveDef, pipeDef, providerDef } from '@angular/core/view/provider';
    export { pureArrayDef, pureObjectDef, purePipeDef } from '@angular/core/view/pure_expression';
    export { queryDef } from '@angular/core/view/query';
    export { ViewRef_, createComponentFactory, getComponentViewDefinitionFactory, nodeValue } from '@angular/core/view/refs';
    export { initServicesIfNeeded } from '@angular/core/view/services';
    export { textDef } from '@angular/core/view/text';
    export { EMPTY_ARRAY, EMPTY_MAP, createRendererType2, elementEventFullName, inlineInterpolate, interpolate, rootRenderNodes, unwrapValue } from '@angular/core/view/util';
    export { viewDef } from '@angular/core/view/view';
    export { attachEmbeddedView, detachEmbeddedView, moveEmbeddedView } from '@angular/core/view/view_attach';
    export * from '@angular/core/view/types';
}

declare module '@angular/core/reflection/reflector' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Type } from '@angular/core/type';
    import { PlatformReflectionCapabilities } from '@angular/core/reflection/platform_reflection_capabilities';
    import { ReflectorReader } from '@angular/core/reflection/reflector_reader';
    import { GetterFn, MethodFn, SetterFn } from '@angular/core/reflection/types';
    export { PlatformReflectionCapabilities } from '@angular/core/reflection/platform_reflection_capabilities';
    export { GetterFn, MethodFn, SetterFn } from '@angular/core/reflection/types';
    /**
        * Provides access to reflection data about symbols. Used internally by Angular
        * to power dependency injection and compilation.
        */
    export class Reflector extends ReflectorReader {
            reflectionCapabilities: PlatformReflectionCapabilities;
            constructor(reflectionCapabilities: PlatformReflectionCapabilities);
            updateCapabilities(caps: PlatformReflectionCapabilities): void;
            factory(type: Type<any>): Function;
            parameters(typeOrFunc: Type<any>): any[][];
            annotations(typeOrFunc: Type<any>): any[];
            propMetadata(typeOrFunc: Type<any>): {
                    [key: string]: any[];
            };
            hasLifecycleHook(type: any, lcProperty: string): boolean;
            getter(name: string): GetterFn;
            setter(name: string): SetterFn;
            method(name: string): MethodFn;
            importUri(type: any): string;
            resourceUri(type: any): string;
            resolveIdentifier(name: string, moduleUrl: string, members: string[] | null, runtime: any): any;
            resolveEnum(identifier: any, name: string): any;
    }
}

declare module '@angular/core/reflection/platform_reflection_capabilities' {
    /**
      * @license
      * Copyright Google Inc. All Rights Reserved.
      *
      * Use of this source code is governed by an MIT-style license that can be
      * found in the LICENSE file at https://angular.io/license
      */
    import { Type } from '@angular/core/type';
    import { GetterFn, MethodFn, SetterFn } from '@angular/core/reflection/types';
    export interface PlatformReflectionCapabilities {
        isReflectionEnabled(): boolean;
        factory(type: Type<any>): Function;
        hasLifecycleHook(type: any, lcProperty: string): boolean;
        parameters(type: Type<any>): any[][];
        annotations(type: Type<any>): any[];
        propMetadata(typeOrFunc: Type<any>): {
            [key: string]: any[];
        };
        getter(name: string): GetterFn;
        setter(name: string): SetterFn;
        method(name: string): MethodFn;
        importUri(type: Type<any>): string;
        resourceUri(type: Type<any>): string;
        resolveIdentifier(name: string, moduleUrl: string, members: string[] | null, runtime: any): any;
        resolveEnum(enumIdentifier: any, name: string): any;
    }
}

declare module '@angular/core/linker/query_list' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Observable } from 'rxjs/Observable';
    /**
        * An unmodifiable list of items that Angular keeps up to date when the state
        * of the application changes.
        *
        * The type of object that {@link Query} and {@link ViewQueryMetadata} provide.
        *
        * Implements an iterable interface, therefore it can be used in both ES6
        * javascript `for (var i of items)` loops as well as in Angular templates with
        * `*ngFor="let i of myList"`.
        *
        * Changes can be observed by subscribing to the changes `Observable`.
        *
        * NOTE: In the future this class will implement an `Observable` interface.
        *
        * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
        * ```typescript
        * @Component({...})
        * class Container {
        *   @ViewChildren(Item) items:QueryList<Item>;
        * }
        * ```
        * @stable
        */
    export class QueryList<T> {
            readonly changes: Observable<any>;
            readonly length: number;
            readonly first: T;
            readonly last: T;
            /**
                * See
                * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
                */
            map<U>(fn: (item: T, index: number, array: T[]) => U): U[];
            /**
                * See
                * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
                */
            filter(fn: (item: T, index: number, array: T[]) => boolean): T[];
            /**
                * See
                * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
                */
            find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;
            /**
                * See
                * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
                */
            reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;
            /**
                * See
                * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
                */
            forEach(fn: (item: T, index: number, array: T[]) => void): void;
            /**
                * See
                * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
                */
            some(fn: (value: T, index: number, array: T[]) => boolean): boolean;
            toArray(): T[];
            toString(): string;
            reset(res: Array<T | any[]>): void;
            notifyOnChanges(): void;
            /** internal */
            setDirty(): void;
            /** internal */
            readonly dirty: boolean;
    }
}

declare module '@angular/core/linker/view_container_ref' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { Injector } from '@angular/core/di/injector';
    import { ComponentFactory, ComponentRef } from '@angular/core/linker/component_factory';
    import { ElementRef } from '@angular/core/linker/element_ref';
    import { NgModuleRef } from '@angular/core/linker/ng_module_factory';
    import { TemplateRef } from '@angular/core/linker/template_ref';
    import { EmbeddedViewRef, ViewRef } from '@angular/core/linker/view_ref';
    /**
        * Represents a container where one or more Views can be attached.
        *
        * The container can contain two kinds of Views. Host Views, created by instantiating a
        * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
        * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
        *
        * The location of the View Container within the containing View is specified by the Anchor
        * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
        * have a single View Container.
        *
        * Root elements of Views attached to this container become siblings of the Anchor Element in
        * the Rendered View.
        *
        * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
        * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
        * @stable
        */
    export abstract class ViewContainerRef {
            /**
                * Anchor element that specifies the location of this container in the containing View.
                * <!-- TODO: rename to anchorElement -->
                */
            readonly abstract element: ElementRef;
            readonly abstract injector: Injector;
            readonly abstract parentInjector: Injector;
            /**
                * Destroys all Views in this container.
                */
            abstract clear(): void;
            /**
                * Returns the {@link ViewRef} for the View located in this container at the specified index.
                */
            abstract get(index: number): ViewRef | null;
            /**
                * Returns the number of Views currently attached to this container.
                */
            readonly abstract length: number;
            /**
                * Instantiates an Embedded View based on the {@link TemplateRef `templateRef`} and inserts it
                * into this container at the specified `index`.
                *
                * If `index` is not specified, the new View will be inserted as the last View in the container.
                *
                * Returns the {@link ViewRef} for the newly created View.
                */
            abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;
            /**
                * Instantiates a single {@link Component} and inserts its Host View into this container at the
                * specified `index`.
                *
                * The component is instantiated using its {@link ComponentFactory} which can be
                * obtained via {@link ComponentFactoryResolver#resolveComponentFactory}.
                *
                * If `index` is not specified, the new View will be inserted as the last View in the container.
                *
                * You can optionally specify the {@link Injector} that will be used as parent for the Component.
                *
                * Returns the {@link ComponentRef} of the Host View created for the newly instantiated Component.
                */
            abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>;
            /**
                * Inserts a View identified by a {@link ViewRef} into the container at the specified `index`.
                *
                * If `index` is not specified, the new View will be inserted as the last View in the container.
                *
                * Returns the inserted {@link ViewRef}.
                */
            abstract insert(viewRef: ViewRef, index?: number): ViewRef;
            /**
                * Moves a View identified by a {@link ViewRef} into the container at the specified `index`.
                *
                * Returns the inserted {@link ViewRef}.
                */
            abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;
            /**
                * Returns the index of the View, specified via {@link ViewRef}, within the current container or
                * `-1` if this container doesn't contain the View.
                */
            abstract indexOf(viewRef: ViewRef): number;
            /**
                * Destroys a View attached to this container at the specified `index`.
                *
                * If `index` is not specified, the last View in the container will be removed.
                */
            abstract remove(index?: number): void;
            /**
                * Use along with {@link #insert} to move a View within the current container.
                *
                * If the `index` param is omitted, the last {@link ViewRef} is detached.
                */
            abstract detach(index?: number): ViewRef | null;
    }
}

declare module '@angular/core/linker/template_ref' {
    /**
        * @license
        * Copyright Google Inc. All Rights Reserved.
        *
        * Use of this source code is governed by an MIT-style license that can be
        * found in the LICENSE file at https://angular.io/license
        */
    import { ElementRef } from '@angular/core/linker/element_ref';
    import { EmbeddedViewRef } from '@angular/core/linker/view_ref';
    /**
        * Represents an Embedded Template that can be used to instantiate Embedded Views.
        *
        * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<ng-template>` element
        * (or directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into
        * the constructor of the directive using the `TemplateRef` Token. Alternatively you can query for
        * the `TemplateRef` from a Component or a Directive via {@link Query}.
        *
        * To instantiate Embedded Views based on a Template, use
        * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
        * View Container.
        * @stable
        */
    export abstract class TemplateRef<C> {
            /**
                * The location in the View where the Embedded View logically belongs to.
                *
                * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
                * inherit from the contexts of this location.
                *
                * Typically new Embedded Views are attached to the View Container of this location, but in
                * advanced use-cases, the View can be attached to a different container while keeping the
                * data-binding and injection context from the original location.
                *
                */
            readonly abstract elementRef: ElementRef;
            abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;
    }
}

